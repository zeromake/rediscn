<!DOCTYPE html>
<html>
	<head>
    <meta charset='utf-8' />
    <link rel="stylesheet" href="/css/styles.css?1436966512">
    <link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href='./images/favicon.png' rel='shortcut icon' />
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>REDIS twitter-clone -- Redis中国用户组（CRUG）</title>
    <meta name="description" content="redis
">
		<script src='./js/jquery-2.0.3.min.js?1426205838'></script>
		<script src='./js/slideout.js?1426205838'></script>
		<script src='./js/app.js?1436878127'></script>
		<script src='./js/base.js?1436878127'></script>
  </head>

<body class=''>
    <div class='mobile-menu slideout-menu'>
      <header class='menu-header'></header>
      <section class='menu-section'>
        <ul class='menu-section-list'>
          <li>
            <a class='home' src='/'>首页</a>
          </li>
          <li>
            <a href='./commands.html'>命令</a>
          </li>
          <li>
            <a href='./clients.html'>客户端</a>
          </li>
          <li>
            <a href='./documentation.html'>文档</a>
          </li>
          <li>
            <a href='./community.html'>社区</a>
          </li>
          <li>
            <a href='./download.html'>下载</a>
          </li>
          <li>
            <a href='./support.html'>支持</a>
          </li>
          <li>
            <a href='./topics/license.html'>许可</a>
          </li>
          <li>
            <a href='./update.html'>更新日志</a>
          </li>
          <li>
            <a href='./articles.html'>文章大全</a>
          </li>
		  <li>
            <a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </li>
          
        </ul>
      </section>
    </div>
    <div class='site-wrapper'>
      <header class='site-header'>
        <nav class='container'>
          <div class='mobile-header'>
            <button class='btn-hamburger js-slideout-toggle'>
              <span class='fa fa-bars'></span>
            </button>
            <a class='home' src='/'>
              <img alt='Redis' src='./images/redis-white.png' />
            </a>
          </div>
          <div class='desktop-header'>
            <a class='home' src='/'>
              <img alt='Redis' src='./images/redis-white.png' />
            </a>
            <a href='./commands.html'>命令</a>
            <a href='./clients.html'>客户端</a>
            <a href='./documentation.html'>文档</a>
            <a href='./community.html'>社区</a>
            <a href='./download.html'>下载</a>
            <a href='./support.html'>支持</a>
            <a href='./topics/license.html'>许可</a>
            <a href='./update.html'>更新日志</a>
            <a href='./articles.html'>文章大全</a>
			<a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </div>
        </nav>
      </header>
      <header class='site-header' style="background-color: #ffffff;">
        <!--
        <nav class='container'>
        	<a href="https://activity.huaweicloud.com/support_plan/index.html?utm_source=huawei&utm_medium=banner&utm_campaign=armredis&utm_content=0624&utm_term=crug" target="_blank">
				<img src="./images/bn/huawei_redis_08.png" style="width:100%;"/>
			</a>
        </nav>
      -->
      </header>
      <div class='site-content'>
<div class='text'>
	<article id='topic'>
		<h1 id="tutorial-design-and-implementation-of-a-simple-twitter-clone-using-php-and-the-redis-key-value-store">Tutorial: Design and implementation of a simple Twitter clone using PHP and the Redis key-value store</h1>

<p>This article describes the design and implementation of a <a href="https://github.com/antirez/retwis">very simple Twitter clone</a> written using PHP with Redis as the only database. The programming community has traditionally considered key-value stores as a special purpose database that couldn’t be used as a drop in replacement for a relational database for the development of web applications. This article will try to show that Redis data structures on top of a key-value layer are an effective data model to implement many kinds of applications.</p>

<p>Before to continue, you may want to play a few seconds with <a href="http://retwis.redis.io">the Retwis online demo</a>, to check what we are going to actually
model. Long story short: it is a toy, but complex enough to be a foundation
in order to learn how to create more complex applications.</p>

<p>Note: the original version of this article was written in 2009 when Redis was
released. It was not exactly clear at the time that the Redis data model was
suitable to write entire applications. Now after 5 years there are many cases of
applications using Redis as their main store, so the goal of the article today
is to be a tutorial for Redis newcomers. You’ll learn how to design a simple
data layout using Redis, and how to apply different data structures.</p>

<p>Our Twitter clone, called <a href="http://retwis.antirez.com">Retwis</a>, is structurally simple, has very good performance, and can be distributed among any number of web and Redis servers with little efforts. You can find the source code <a href="http://code.google.com/p/redis/downloads/list">here</a>.</p>

<p>I use PHP for the example since it can be read by everybody. The same (or better) results can be obtained using Ruby, Python, Erlang, and so on.
A few clones exist (however not all the clones use the same data layout as the
current version of this tutorial, so please, stick with the official PHP
implementation for the sake of following the article better).</p>

<ul>
  <li><a href="http://retwisrb.danlucraft.com/">Retwis-RB</a> is a port of Retwis to Ruby and Sinatra written by Daniel Lucraft! Full source code is included of course, and a link to its Git repository appears in the footer of this article. The rest of this article targets PHP, but Ruby programmers can also check the Retwis-RB source code since it’s conceptually very similar.</li>
  <li><a href="http://retwisj.cloudfoundry.com/">Retwis-J</a> is a port of Retwis to Java, using the Spring Data Framework, written by <a href="http://twitter.com/costinl">Costin Leau</a>. Its source code can be found on <a href="https://github.com/SpringSource/spring-data-keyvalue-examples">GitHub</a>, and there is comprehensive documentation available at <a href="http://j.mp/eo6z6I">springsource.org</a>.</li>
</ul>

<h2 id="what-is-a-key-value-store">What is a Key-value store?</h2>
<p>The essence of a key-value store is the ability to store some data, called a <em>value</em>, inside a key. The value can be retrieved later only if we know the specific key it was stored in. There is no direct way to search for a key by value. In a sense, it is like a very large hash/dictionary, but it is persistent, i.e. when your application ends, the data doesn’t go away. So, for example, I can use the command <code class="language-plaintext highlighter-rouge">SET</code> to store the value <em>bar</em> in the key <em>foo</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET foo bar
</code></pre></div></div>

<p>Redis stores data permanently, so if I later ask “<em>What is the value stored in key foo?</em>” Redis will reply with <em>bar</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET foo =&gt; bar
</code></pre></div></div>

<p>Other common operations provided by key-value stores are <code class="language-plaintext highlighter-rouge">DEL</code>, to delete a given key and its associated value, SET-if-not-exists (called <code class="language-plaintext highlighter-rouge">SETNX</code> on Redis), to assign a value to a key only if the key does not already exist, and <code class="language-plaintext highlighter-rouge">INCR</code>, to atomically increment a number stored in a given key:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET foo 10
INCR foo =&gt; 11
INCR foo =&gt; 12
INCR foo =&gt; 13
</code></pre></div></div>

<h2 id="atomic-operations">Atomic operations</h2>

<p>There is something special about <code class="language-plaintext highlighter-rouge">INCR</code>. Think about why Redis provides such an operation if we can do it ourselves with a bit of code? After all, it is as simple as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = GET foo
x = x + 1
SET foo x
</code></pre></div></div>

<p>The problem is that incrementing this way will work as long as there is only one client working with the key <em>foo</em> at one time. See what happens if two clients are accessing this key at the same time:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = GET foo (yields 10)
y = GET foo (yields 10)
x = x + 1 (x is now 11)
y = y + 1 (y is now 11)
SET foo x (foo is now 11)
SET foo y (foo is now 11)
</code></pre></div></div>

<p>Something is wrong! We incremented the value two times, but instead of going from 10 to 12, our key holds 11. This is because the increment done with <code class="language-plaintext highlighter-rouge">GET / increment / SET</code> <em>is not an atomic operation</em>. Instead the INCR provided by Redis, Memcached, …, are atomic implementations, and the server will take care of protecting the key during the time needed to complete the increment in order to prevent simultaneous accesses.</p>

<p>What makes Redis different from other key-value stores is that it provides other operations similar to INCR that can be used to model complex problems. This is why you can use Redis to write whole web applications without using another database like an SQL database, and without going crazy.</p>

<h2 id="beyond-key-value-stores-lists">Beyond key-value stores: lists</h2>

<p>In this section we will see which Redis features we need to build our Twitter clone. The first thing to know is that Redis values can be more than strings. Redis supports Lists, Sets, Hashes, Sorted Sets, Bitmaps, and HyperLogLog types as values, and there are atomic operations to operate on them so we are safe even with multiple accesses to the same key. Let’s start with Lists:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LPUSH mylist a (now mylist holds 'a')
LPUSH mylist b (now mylist holds 'b','a')
LPUSH mylist c (now mylist holds 'c','b','a')
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">LPUSH</code> means <em>Left Push</em>, that is, add an element to the left (or to the head) of the list stored in <em>mylist</em>. If the key <em>mylist</em> does not exist it is automatically created as an empty list before the PUSH operation. As you can imagine, there is also an <code class="language-plaintext highlighter-rouge">RPUSH</code> operation that adds the element to the right of the list (on the tail). This is very useful for our Twitter clone. User updates can be added to a list stored in <code class="language-plaintext highlighter-rouge">username:updates</code>, for instance.</p>

<p>There are operations to get data from Lists, of course. For instance, LRANGE returns a range from the list, or the whole list.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LRANGE mylist 0 1 =&gt; c,b
</code></pre></div></div>

<p>LRANGE uses zero-based indexes - that is the first element is 0, the second 1, and so on. The command arguments are <code class="language-plaintext highlighter-rouge">LRANGE key first-index last-index</code>. The <em>last-index</em> argument can be negative, with a special meaning: -1 is the last element of the list, -2 the penultimate, and so on. So, to get the whole list use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LRANGE mylist 0 -1 =&gt; c,b,a
</code></pre></div></div>

<p>Other important operations are LLEN that returns the number of elements in the list, and LTRIM that is like LRANGE but instead of returning the specified range <em>trims</em> the list, so it is like <em>Get range from mylist, Set this range as new value</em> but does so atomically.</p>

<h2 id="the-set-data-type">The Set data type</h2>

<p>Currently we don’t use the Set type in this tutorial, but since we use
Sorted Sets, which are kind of a more capable version of Sets, it is better
to start introducing Sets first (which are a very useful data structure
per se), and later Sorted Sets.</p>

<p>There are more data types than just Lists. Redis also supports Sets, which are unsorted collections of elements. It is possible to add, remove, and test for existence of members, and perform the intersection between different Sets. Of course it is possible to get the elements of a set. Some examples will make it more clear. Keep in mind that <code class="language-plaintext highlighter-rouge">SADD</code> is the <em>add to set</em> operation, <code class="language-plaintext highlighter-rouge">SREM</code> is the <em>remove from set</em> operation, <em>sismember</em> is the <em>test if member</em> operation, and <code class="language-plaintext highlighter-rouge">SINTER</code> is the <em>perform intersection</em> operation. Other operations are <code class="language-plaintext highlighter-rouge">SCARD</code> to get the cardinality (the number of elements) of a Set, and <code class="language-plaintext highlighter-rouge">SMEMBERS</code> to return all the members of a Set.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SADD myset a
SADD myset b
SADD myset foo
SADD myset bar
SCARD myset =&gt; 4
SMEMBERS myset =&gt; bar,a,foo,b
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">SMEMBERS</code> does not return the elements in the same order we added them since Sets are <em>unsorted</em> collections of elements. When you want to store in order it is better to use Lists instead. Some more operations against Sets:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SADD mynewset b
SADD mynewset foo
SADD mynewset hello
SINTER myset mynewset =&gt; foo,b
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SINTER</code> can return the intersection between Sets but it is not limited to two sets. You may ask for the intersection of 4,5, or 10000 Sets. Finally let’s check how SISMEMBER works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SISMEMBER myset foo =&gt; 1
SISMEMBER myset notamember =&gt; 0
</code></pre></div></div>

<h2 id="the-sorted-set-data-type">The Sorted Set data type</h2>

<p>Sorted Sets are similar to Sets: collection of elements. However in Sorted
Sets each element is associated with a floating point value, called the
<em>element score</em>. Because of the score, elements inside a sorted set are
ordered, since we can always compare two elements by score (and if the score
happens to be the same, we compare the two elements as strings).</p>

<p>Like Sets in Sorted Sets it is not possible to add repeated elements, every
element is unique. However it is possible to update an element’s score.</p>

<p>Sorted Set commands are prefixed with <code class="language-plaintext highlighter-rouge">Z</code>. The following is an example
of Sorted Sets usage:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZADD zset 10 a
ZADD zset 5 b
ZADD zset 12.55 c
ZRANGE zset 0 -1 =&gt; b,a,c
</code></pre></div></div>

<p>In the above example we added a few elements with <code class="language-plaintext highlighter-rouge">ZADD</code>, and later retrieved
the elements with <code class="language-plaintext highlighter-rouge">ZRANGE</code>. As you can see the elements are returned in order
according to their score. In order to check if a given element exists, and
also to retrieve its score if it exists, we use the <code class="language-plaintext highlighter-rouge">ZSCORE</code> command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZSCORE zset a =&gt; 10
ZSCORE zset non_existing_element =&gt; NULL
</code></pre></div></div>

<p>Sorted Sets are a very powerful data structure, you can query elements by
score range, lexicographically, in reverse order, and so forth.
To know more <a href="http://redis.io/commands/#sorted_set">please check the Sorted Set sections in the official Redis commands documentation</a>.</p>

<h2 id="the-hash-data-type">The Hash data type</h2>

<p>This is the last data structure we use in our program, and is extremely easy
to gasp since there is an equivalent in almost every programming language out
there: Hashes. Redis Hashes are basically like Ruby or Python hashes, a
collection of fields associated with values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HMSET myuser name Salvatore surname Sanfilippo country Italy
HGET myuser surname =&gt; Sanfilippo
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">HMSET</code> can be used to set fields in the hash, that can be retrieved with
<code class="language-plaintext highlighter-rouge">HGET</code> later. It is possible to check if a field exists with <code class="language-plaintext highlighter-rouge">HEXISTS</code>, or
to increment an hash field with <code class="language-plaintext highlighter-rouge">HINCRBY</code> and so forth.</p>

<p>Hashes are the ideal data structure to represent <em>objects</em>. For example we
use Hashes in order to represent Users and Updates in our Twitter clone.</p>

<p>Okay, we just exposed the basics of the Redis main data structures,
we are ready to start coding!</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>If you haven’t downloaded the <a href="https://github.com/antirez/retwis">Retwis source code</a> already please grab it now. It contains a few PHP files, and also a copy of <a href="https://github.com/nrk/predis">Predis</a>, the PHP client library we use in this example.</p>

<p>Another thing you probably want is a working Redis server. Just get the source, build with make, run with ./redis-server, and you’re ready to go. No configuration is required at all in order to play with or run Retwis on your computer.</p>

<h2 id="data-layout">Data layout</h2>

<p>When working with a relational database, a database schema must be designed so that we’d know the tables, indexes, and so on that the database will contain. We don’t have tables in Redis, so what do we need to design? We need to identify what keys are needed to represent our objects and what kind of values this keys need to hold.</p>

<p>Let’s start with Users. We need to represent users, of course, with their username, userid, password, the set of users following a given user, the set of users a given user follows, and so on. The first question is, how should we identify a user? Like in a relational DB, a good solution is to identify different users with different numbers, so we can associate a unique ID with every user. Every other reference to this user will be done by id. Creating unique IDs is very simple to do by using our atomic <code class="language-plaintext highlighter-rouge">INCR</code> operation. When we create a new user we can do something like this, assuming the user is called “antirez”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INCR next_user_id =&gt; 1000
HMSET user:1000 username antirez password p1pp0
</code></pre></div></div>

<p><em>Note: you should use an hashed password in a real application, for simplicity
we store the password in clear text.</em></p>

<p>We use the <code class="language-plaintext highlighter-rouge">next_user_id</code> key in order to always get an unique ID for every new user. Then we use this unique ID to name the key holding an Hash with user’s data. <em>This is a common design pattern</em> with key-values stores! Keep it in mind.
Besides the fields already defined, we need some more stuff in order to fully define a User. For example, sometimes it can be useful to be able to get the user ID from the username, so every time we add an user, we also populate the <code class="language-plaintext highlighter-rouge">users</code> key, which is an Hash, with the username as field, and its ID as value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HSET users antirez 1000
</code></pre></div></div>

<p>This may appear strange at first, but remember that we are only able to access data in a direct way, without secondary indexes. It’s not possible to tell Redis to return the key that holds a specific value. This is also <em>our strength</em>. This new paradigm is forcing us to organize data so that everything is accessible by <em>primary key</em>, speaking in relational DB terms.</p>

<h2 id="followers-following-and-updates">Followers, following, and updates</h2>

<p>There is another central need in our system. A user might have users who follow them, which we’ll call their followers. A user might follow other users, which we’ll call a following. We have a perfect data structure for this. That is… Sets.
The uniqueness of Sets elements, and the fact we can test in constant time for
existence, are two interesting features. However what about also remembering
the time at which a given user started following another one? In an enhanced
version of our simple Twitter clone this may be useful, so instead of using
a simple Set, we use a Sorted Set, using the user ID of the following or follower
user as element, and the unix time at which the relation between the users
was created, as our score.</p>

<p>So let’s define our keys:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>followers:1000 =&gt; Sorted Set of uids of all the followers users
following:1000 =&gt; Sorted Set of uids of all the following users
</code></pre></div></div>

<p>We can add new followers with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZADD followers:1000 1401267618 1234 =&gt; Add user 1234 with time 1401267618
</code></pre></div></div>

<p>Another important thing we need is a place were we can add the updates to display in the user’s home page. We’ll need to access this data in chronological order later, from the most recent update to the oldest, so the perfect kind of data structure for this is a List. Basically every new update will be <code class="language-plaintext highlighter-rouge">LPUSH</code>ed in the user updates key, and thanks to <code class="language-plaintext highlighter-rouge">LRANGE</code>, we can implement pagination and so on. Note that we use the words <em>updates</em> and <em>posts</em> interchangeably, since updates are actually “little posts” in some way.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>posts:1000 =&gt; a List of post ids - every new post is LPUSHed here.
</code></pre></div></div>

<p>This list is basically the User timeline. We’ll push the IDs of her/his own
posts, and, the IDs of all the posts of created by the following users.
Basically we implement a write fanout.</p>

<h2 id="authentication">Authentication</h2>

<p>OK, we have more or less everything about the user except for authentication. We’ll handle authentication in a simple but robust way: we don’t want to use PHP sessions, our system must be ready to be distributed among different web servers easily, so we’ll keep the whole state in our Redis database. All we need is a random <strong>unguessable</strong> string to set as the cookie of an authenticated user, and a key that will contain the user ID of the client holding the string.</p>

<p>We need two things in order to make this thing work in a robust way.
First: the current authentication <em>secret</em> (the random unguessable string)
should be part of the User object, so when the user is created we also set
an <code class="language-plaintext highlighter-rouge">auth</code> field in its Hash:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HSET user:1000 auth fea5e81ac8ca77622bed1c2132a021f9
</code></pre></div></div>

<p>Moreover, we need a way to map authentication secrets to user IDs, so
we also take an <code class="language-plaintext highlighter-rouge">auths</code> key, which has as value an Hash type mapping
authentication secrets to user IDs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HSET auths fea5e81ac8ca77622bed1c2132a021f9 1000
</code></pre></div></div>

<p>In order to authenticate a user we’ll do these simple steps ( see the <code class="language-plaintext highlighter-rouge">login.php</code> file in the Retwis source code):</p>

<ul>
  <li>Get the username and password via the login form</li>
  <li>Check if the <code class="language-plaintext highlighter-rouge">username</code> field actually exists in the <code class="language-plaintext highlighter-rouge">users</code> Hash.</li>
  <li>If it exists we have the user id, (i.e. 1000)</li>
  <li>Check if user:1000 password matches, if not, return an error message</li>
  <li>Ok authenticated! Set “fea5e81ac8ca77622bed1c2132a021f9” (the value of user:1000 <code class="language-plaintext highlighter-rouge">auth</code> field) as the “auth” cookie.</li>
</ul>

<p>This is the actual code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include("retwis.php");

# Form sanity checks
if (!gt("username") || !gt("password"))
    goback("You need to enter both username and password to login.");

# The form is ok, check if the username is available
$username = gt("username");
$password = gt("password");
$r = redisLink();
$userid = $r-&gt;hget("users",$username);
if (!$userid)
    goback("Wrong username or password");
$realpassword = $r-&gt;hget("user:$userid","password");
if ($realpassword != $password)
    goback("Wrong useranme or password");

# Username / password OK, set the cookie and redirect to index.php
$authsecret = $r-&gt;hget("user:$userid","auth");
setcookie("auth",$authsecret,time()+3600*24*365);
header("Location: index.php");
</code></pre></div></div>

<p>This happens every time a user logs in, but we also need a function <code class="language-plaintext highlighter-rouge">isLoggedIn</code> in order to check if a given user is already authenticated or not. These are the logical steps preformed by the <code class="language-plaintext highlighter-rouge">isLoggedIn</code> function:</p>

<ul>
  <li>Get the “auth” cookie from the user. If there is no cookie, the user is not logged in, of course. Let’s call the value of the cookie <code class="language-plaintext highlighter-rouge">&lt;authcookie&gt;</code></li>
  <li>Check if <code class="language-plaintext highlighter-rouge">&lt;authcookie&gt;</code> field in the <code class="language-plaintext highlighter-rouge">auths</code> Hash exists, and what the value (the user ID) is (1000 in the example).</li>
  <li>In order for the system to be more robust, also verify that user:1000 auth field also matches.</li>
  <li>OK the user is authenticated, and we loaded a bit of information in the $User global variable.</li>
</ul>

<p>The code is simpler than the description, possibly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function isLoggedIn() {
    global $User, $_COOKIE;

    if (isset($User)) return true;

    if (isset($_COOKIE['auth'])) {
        $r = redisLink();
        $authcookie = $_COOKIE['auth'];
        if ($userid = $r-&gt;hget("auths",$authcookie)) {
            if ($r-&gt;hget("user:$userid","auth") != $authcookie) return false;
            loadUserInfo($userid);
            return true;
        }
    }
    return false;
}

function loadUserInfo($userid) {
    global $User;

    $r = redisLink();
    $User['id'] = $userid;
    $User['username'] = $r-&gt;hget("user:$userid","username");
    return true;
}
</code></pre></div></div>

<p>Having <code class="language-plaintext highlighter-rouge">loadUserInfo</code> as a separate function is overkill for our application, but it’s a good approach in a complex application. The only thing that’s missing from all the authentication is the logout. What do we do on logout? That’s simple, we’ll just change the random string in user:1000 <code class="language-plaintext highlighter-rouge">auth</code> field, remove the old authentication secret from the <code class="language-plaintext highlighter-rouge">auths</code> Hash., and add the new one.</p>

<p><em>Important:</em> the logout procedure explains why we don’t just authenticate the user after looking up the authentication secret in the <code class="language-plaintext highlighter-rouge">auths</code> Hash, but double check it against user:1000 <code class="language-plaintext highlighter-rouge">auth</code> field. The true authentication string is the latter, while the <code class="language-plaintext highlighter-rouge">auths</code> Hash is just an authentication field that may even be volatile, or, if there are bugs in the program or a script gets interrupted, we may even end with multiple entries in the <code class="language-plaintext highlighter-rouge">auths</code> key pointing to the same user ID. The logout code is the following (logout.php):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include("retwis.php");

if (!isLoggedIn()) {
    header("Location: index.php");
    exit;
}

$r = redisLink();
$newauthsecret = getrand();
$userid = $User['id'];
$oldauthsecret = $r-&gt;hget("user:$userid","auth");

$r-&gt;hset("user:$userid","auth",$newauthsecret);
$r-&gt;hset("auths",$newauthsecret,$userid);
$r-&gt;hdel("auths",$oldauthsecret);

header("Location: index.php");
</code></pre></div></div>

<p>That is just what we described and should be simple to understand.</p>

<h2 id="updates">Updates</h2>

<p>Updates, also known as posts, are even simpler. In order to create a new post in the database we do something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INCR next_post_id =&gt; 10343
HMSET post:10343 user_id $owner_id time $time body "I'm having fun with Retwis"
</code></pre></div></div>

<p>As you can see each post is just represented by an Hash with three fields. The ID of the user owning the post, the time at which the post was published, and finally the body of the post, which is, the actual status message.</p>

<p>After we create a post and we obtain the post ID, we need to LPUSH the ID in the timeline of every user that is following the author of the post, and of course in the list of posts of the author itself (everybody is virtually following herself/himself). This is the file <code class="language-plaintext highlighter-rouge">post.php</code> that shows how this is performed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include("retwis.php");

if (!isLoggedIn() || !gt("status")) {
    header("Location:index.php");
    exit;
}

$r = redisLink();
$postid = $r-&gt;incr("next_post_id");
$status = str_replace("\n"," ",gt("status"));
$r-&gt;hmset("post:$postid","user_id",$User['id'],"time",time(),"body",$status);
$followers = $r-&gt;zrange("followers:".$User['id'],0,-1);
$followers[] = $User['id']; /* Add the post to our own posts too */

foreach($followers as $fid) {
    $r-&gt;lpush("posts:$fid",$postid);
}
# Push the post on the timeline, and trim the timeline to the
# newest 1000 elements.
$r-&gt;lpush("timeline",$postid);
$r-&gt;ltrim("timeline",0,1000);

header("Location: index.php");
</code></pre></div></div>

<p>The core of the function is the <code class="language-plaintext highlighter-rouge">foreach</code> loop. We use <code class="language-plaintext highlighter-rouge">ZRANGE</code> to get all the followers of the current user, then the loop will LPUSH the push the post in every follower timeline List.</p>

<p>Note that we also maintain a global timeline for all the posts, so that in the Retwis home page we can show everybody’s updates easily. This requires just doing an <code class="language-plaintext highlighter-rouge">LPUSH</code> to the <code class="language-plaintext highlighter-rouge">timeline</code> List. Let’s face it, aren’t you start thinking it was a bit strange to have to sort things added in chronological order using <code class="language-plaintext highlighter-rouge">ORDER BY</code> with SQL? I think so.</p>

<p>There is an interesting thing to notice in the code above: we use a new
command called <code class="language-plaintext highlighter-rouge">LTRIM</code> after we perform the <code class="language-plaintext highlighter-rouge">LPUSH</code> operation in the global
timeline. This is used in order to trim the list to just 1000 elements. The
global timeline is actually only used in order to show a few posts in the
home page, there is no need to have the full history of all the posts.</p>

<p>Basically <code class="language-plaintext highlighter-rouge">LTRIM</code> + <code class="language-plaintext highlighter-rouge">LPUSH</code> is a way to create a <em>capped collection</em> in Redis.</p>

<h2 id="paginating-updates">Paginating updates</h2>

<p>Now it should be pretty clear how we can use <code class="language-plaintext highlighter-rouge">LRANGE</code> in order to get ranges of posts, and render these posts on the screen. The code is simple:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function showPost($id) {
    $r = redisLink();
    $post = $r-&gt;hgetall("post:$id");
    if (empty($post)) return false;

    $userid = $post['user_id'];
    $username = $r-&gt;hget("user:$userid","username");
    $elapsed = strElapsed($post['time']);
    $userlink = "&lt;a class=\"username\" href=\"profile.php?u=".urlencode($username)."\"&gt;".utf8entities($username)."&lt;/a&gt;";

    echo('&lt;div class="post"&gt;'.$userlink.' '.utf8entities($post['body'])."&lt;br&gt;");
    echo('&lt;i&gt;posted '.$elapsed.' ago via web&lt;/i&gt;&lt;/div&gt;');
    return true;
}

function showUserPosts($userid,$start,$count) {
    $r = redisLink();
    $key = ($userid == -1) ? "timeline" : "posts:$userid";
    $posts = $r-&gt;lrange($key,$start,$start+$count);
    $c = 0;
    foreach($posts as $p) {
        if (showPost($p)) $c++;
        if ($c == $count) break;
    }
    return count($posts) == $count+1;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">showPost</code> will simply convert and print a Post in HTML while <code class="language-plaintext highlighter-rouge">showUserPosts</code> gets a range of posts and then passes them to <code class="language-plaintext highlighter-rouge">showPosts</code>.</p>

<p><em>Note: <code class="language-plaintext highlighter-rouge">LRANGE</code> is not very efficient if the list of posts start to be very
big, and we want to access elements which are in the middle of the list, since Redis Lists are backed by linked lists. If a system is designed for
deep pagination of million of items, it is better to resort to Sorted Sets
instead.</em></p>

<h2 id="following-users">Following users</h2>

<p>It is not hard, but we did not yet checked how we create following / follower relationships. If user ID 1000 (antirez) wants to follow user ID 5000 (pippo), we need to create both a following and a follower relationship. We just need to <code class="language-plaintext highlighter-rouge">ZADD</code> calls:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ZADD following:1000 5000
    ZADD followers:5000 1000
</code></pre></div></div>

<p>Note the same pattern again and again. In theory with a relational database the list of following and followers would be contained in a single table with fields like <code class="language-plaintext highlighter-rouge">following_id</code> and <code class="language-plaintext highlighter-rouge">follower_id</code>. You can extract the followers or following of every user using an SQL query. With a key-value DB things are a bit different since we need to set both the <code class="language-plaintext highlighter-rouge">1000 is following 5000</code> and <code class="language-plaintext highlighter-rouge">5000 is followed by 1000</code> relations. This is the price to pay, but on the other hand accessing the data is simpler and extremely fast. Having these things as separate sets allows us to do interesting stuff. For example, using <code class="language-plaintext highlighter-rouge">ZINTERSTORE</code> we can have the intersection of ‘following’ of two different users, so we may add a feature to our Twitter clone so that it is able to tell you very quickly when you visit somebody else’s profile, “you and Alice have 34 followers in common”, and things like that.</p>

<p>You can find the code that sets or removes a following / follower relation in the <code class="language-plaintext highlighter-rouge">follow.php</code> file.</p>

<h2 id="making-it-horizontally-scalable">Making it horizontally scalable</h2>

<p>Gentle reader, if you reached this point you are already a hero. Thank you. Before talking about scaling horizontally it is worth checking performance on a single server. Retwis is <em>extremely fast</em>, without any kind of cache. On a very slow and loaded server, an Apache benchmark with 100 parallel clients issuing 100000 requests measured the average pageview to take 5 milliseconds. This means you can serve millions of users every day with just a single Linux box, and this one was monkey ass slow… Imagine the results with more recent hardware.</p>

<p>However you can’t go with a single server forever, how do you scale a key-value
store?</p>

<p>Retwis does not perform any multi-keys operation, so making it scalable is
simple: you may use client-side sharding, or something like a sharding proxy
like Twemproxy, or the upcoming Redis Cluster.</p>

<p>To know more about those topics please read
<a href="/topics/partitioning">our documentation about sharding</a>. However here the point
to stress is that in a key-value store, if you design with care, the data set
is split among <strong>many independent small keys</strong>. To distribute those keys
to multiple nodes is more straightforward and predictable compared to using
a semantically more complex database system.</p>

	</article>
	
</div>
<script>
		if(isRediscnPc()){
			var s = "_" + Math.random().toString(36).slice(2);
			document.write('<div style="margin-bottom:10px;" id="' + s + '"></div>');
			(window.slotbydup = window.slotbydup || []).push({
				id: "u3556359",
				container:  s
			});
			document.write('<scr'+'ipt type="text/javascr'+'ipt" src="//cpro.baidustatic.com/cpro/ui/c.js" async="async" defer="defer" ></scr'+'ipt>');
		}
	
</script>
<footer class='site-footer'>
        <div class='container'>
          本站资源翻译自<a href="http://redis.io" target="_blank">redis.io</a>，
					由<a src="./aboutus.html">redis.cn翻译团队</a>翻译，
					更新日志请点击<a src="./update.html">这里</a>查看，
					翻译原文版权归redis.io官方所有，翻译不正确的地方欢迎大家指出。<br> 
					感谢各界爱心人士的热心捐赠，CRUG的成长离不开大家的帮助和支持，特别是<a src="./donation.html">Redis捐赠清单</a>里面的各位伙伴。<br>
					联系Email:<a href="mailto:admin@redis.cn">admin@redis.cn</a>，
					redis交流群：<a href="#">579708237</a> &nbsp; 
					<a href="https://beian.miit.gov.cn" target="_blank">京ICP备15003959号-2</a> &nbsp;
					<br>    
					<span style="font-weight:bold;color:#000000;">友情链接：</span>
					<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=fvilu0rm" target="_blank">阿里云</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">DBA的罗浮宫</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">VIP-陈群博客</a> &nbsp;
					<a href="http://lib.csdn.net/base/redis" target="_blank">Redis-知识库</a> &nbsp;
					<a href="http://www.kubernetes.org.cn" target="_blank" >Kubernetes</a> &nbsp;	
					<a href="https://www.fanghouguo.com" target="_blank" >方后国的博客</a> &nbsp;	
					<a href="https://aff.gae1s.com/aff.php?aff=10022" target="_blank" >ChromeGAE</a> &nbsp;	
					<a href="http://top.chinaz.com/" target="_blank" >网站排行榜</a> &nbsp;	
        </div>
      </footer>
    </div>
  </body>
</html>


<script>
	if(!isMobileBrowser()){
		window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"0","bdPos":"right","bdTop":"54.5"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	}
</script>

<script type='text/javascript'>
lastScrollY=0;

function heartBeat(){ 
	var diffY;
	if (document.documentElement && document.documentElement.scrollTop)
	diffY = document.documentElement.scrollTop;
	else if (document.body)
	diffY = document.body.scrollTop
	else
	{/*Netscape stuff*/}
	//alert(diffY);
	percent=.1*(diffY-lastScrollY); 
	if(percent>0)percent=Math.ceil(percent); 
	else percent=Math.floor(percent); 
	document.getElementById("lovexin12").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	document.getElementById("lovexin14").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	lastScrollY=lastScrollY+percent; 
	//alert(lastScrollY);
}

if(!isMobileBrowser()){
		//suspendcode12="<DIV id=\"lovexin12\" style='width:120px;height:270px;left:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://bbs.huaweicloud.com/forum/thread-16526-1-1.html' target='_blank'><img src='./images/couplets/hw_cp_20190411_01.png'/></a></div>"
		//suspendcode14="<DIV id=\"lovexin14\" style='width:120px;height:270px;right:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://activity.huaweicloud.com/2019june_promotion/index.html?utm_source=huawei&utm_medium=other&utm_campaign=618dacu&utm_content=0614#app-connection' target='_blank'><img src='./images/couplets/hw_cp_20190612.png'/></a></div>"
		//document.write(suspendcode12); 
		//document.write(suspendcode14); 
		//window.setInterval("heartBeat()",1);
}

$(document).ready(function(){ 
	
});
</script>
