<!DOCTYPE html>
<html>
	<head>
    <meta charset='utf-8' />
    <link rel="stylesheet" href="/css/styles.css?1436966512">
    <link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href='./images/favicon.png' rel='shortcut icon' />
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>REDIS data-types-intro -- Redis中文资料站 -- Redis中国用户组（CRUG）</title>
    <meta name="description" content="redis
">
		<script src='./js/jquery-2.0.3.min.js?1426205838'></script>
		<script src='./js/slideout.js?1426205838'></script>
		<script src='./js/app.js?1436878127'></script>
		<script src='./js/base.js?1436878127'></script>
  </head>

<body class=''>
    <div class='mobile-menu slideout-menu'>
      <header class='menu-header'></header>
      <section class='menu-section'>
        <ul class='menu-section-list'>
          <li>
            <a class='home' src='/'>首页</a>
          </li>
          <li>
            <a href='./commands.html'>命令</a>
          </li>
          <li>
            <a href='./clients.html'>客户端</a>
          </li>
          <li>
            <a href='./documentation.html'>文档</a>
          </li>
          <li>
            <a href='./community.html'>社区</a>
          </li>
          <li>
            <a href='./download.html'>下载</a>
          </li>
          <li>
            <a href='./support.html'>支持</a>
          </li>
          <li>
            <a href='./topics/license.html'>许可</a>
          </li>
          <li>
            <a href='./update.html'>更新日志</a>
          </li>
          <li>
            <a href='./articles.html'>文章大全</a>
          </li>
		  <li>
            <a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </li>
          
        </ul>
      </section>
    </div>
    <div class='site-wrapper'>
      <header class='site-header'>
        <nav class='container'>
          <div class='mobile-header'>
            <button class='btn-hamburger js-slideout-toggle'>
              <span class='fa fa-bars'></span>
            </button>
            <a class='home' src='/'>
              <img alt='Redis' src='./images/redis-white.png' />
            </a>
          </div>
          <div class='desktop-header'>
            <a class='home' src='/'>
              <img alt='Redis' src='./images/redis-white.png' />
            </a>
            <a href='./commands.html'>命令</a>
            <a href='./clients.html'>客户端</a>
            <a href='./documentation.html'>文档</a>
            <a href='./community.html'>社区</a>
            <a href='./download.html'>下载</a>
            <a href='./support.html'>支持</a>
            <a href='./topics/license.html'>许可</a>
            <a href='./update.html'>更新日志</a>
            <a href='./articles.html'>文章大全</a>
			<a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </div>
        </nav>
      </header>
      <header class='site-header' style="background-color: #ffffff;">
        <!--
        <nav class='container'>
        	<a href="https://activity.huaweicloud.com/support_plan/index.html?utm_source=huawei&utm_medium=banner&utm_campaign=armredis&utm_content=0624&utm_term=crug" target="_blank">
				<img src="./images/bn/huawei_redis_08.png" style="width:100%;"/>
			</a>
        </nav>
      -->
      </header>
      <div class='site-content'>
<div class='text'>
	<article id='topic'>
		<h1 id="redis-数据类型介绍">Redis 数据类型介绍</h1>

<p>你也许已经知道Redis并不是简单的key-value存储，实际上他是一个数据结构服务器，支持不同类型的值。也就是说，你不必仅仅把字符串当作键所指向的值。下列这些数据类型都可作为值类型：</p>

<ul>
  <li>二进制安全的字符串</li>
  <li>Lists: 按插入顺序排序的字符串元素的集合。他们基本上就是<em>链表（linked lists）</em>。</li>
  <li>Sets: 不重复且无序的字符串元素的集合。</li>
  <li>Sorted sets,类似Sets,但是每个字符串元素都关联到一个叫<em>score</em>浮动数值（floating number value）。里面的元素总是通过score进行着排序，所以不同的是，它是可以检索的一系列元素。（例如你可能会问：给我前面10个或者后面10个元素）。</li>
  <li>Hashes,由field和关联的value组成的map。field和value都是字符串的。这和Ruby、Python的hashes很像。</li>
  <li>Bit arrays (或者说 simply bitmaps): 通过特殊的命令，你可以将 String 值当作一系列 bits 处理：可以设置和清除单独的 bits，数出所有设为 1 的 bits 的数量，找到最前的被设为 1 或 0 的 bit，等等。</li>
  <li>HyperLogLogs: 这是被用于估计一个 set 中元素数量的概率性的数据结构。别害怕，它比看起来的样子要简单…参见本教程的 HyperLogLog 部分。D</li>
</ul>

<p>学习这些数据类型的原理，以及如何使用它们解决 <a href="/commands">command reference</a> 中的特定问题，并不总是不关紧要的。所以，本文档是一个关于 Redis 数据类型和它们最常见特性的导论。
在所有的例子中，我们将使用 <code class="language-plaintext highlighter-rouge">redis-cli</code> 工具。它是一个简单而有用的命令行工具，用于向 Redis 服务器发出命令。</p>

<h2 id="redis-keys">Redis keys</h2>

<p>Redis key值是二进制安全的，这意味着可以用任何二进制序列作为key值，从形如”foo”的简单字符串到一个JPEG文件的内容都可以。空字符串也是有效key值。</p>

<p>关于key的几条规则：</p>

<ul>
  <li>太长的键值不是个好主意，例如1024字节的键值就不是个好主意，不仅因为消耗内存，而且在数据中查找这类键值的计算成本很高。</li>
  <li>太短的键值通常也不是好主意，如果你要用”u:1000:pwd”来代替”user:1000:password”，这没有什么问题，但后者更易阅读，并且由此增加的空间消耗相对于key object和value object本身来说很小。当然，没人阻止您一定要用更短的键值节省一丁点儿空间。</li>
  <li>最好坚持一种模式。例如：”object-type:id:field”就是个不错的注意，像这样”user:1000:password”。我喜欢对多单词的字段名中加上一个点，就像这样：”comment:1234:reply.to”。</li>
</ul>

<h2 id="redis-strings">Redis Strings</h2>

<p>这是最简单Redis类型。如果你只用这种类型，Redis就像一个可以持久化的memcached服务器（注：memcache的数据仅保存在内存中，服务器重启后，数据将丢失）。</p>

<p>我们用redis-cli来玩一下字符串类型：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; set mykey somevalue
OK
&gt; get mykey
"somevalue"
</code></pre></div></div>

<p>正如你所见到的，通常用SET command 和 GET command来设置和获取字符串值。</p>

<p>值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一副jpeg图片。值的长度不能超过512 MB。</p>

<p><code class="language-plaintext highlighter-rouge">SET</code> 命令有些有趣的操作，例如，当key存在时<code class="language-plaintext highlighter-rouge">SET</code>会失败，或相反的，当key不存在时它只会成功。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; set mykey newval nx
(nil)
&gt; set mykey newval xx
OK
</code></pre></div></div>

<p>虽然字符串是Redis的基本值类型，但你仍然能通过它完成一些有趣的操作。例如：原子递增：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; set counter 100
OK
&gt; incr counter
(integer) 101
&gt; incr counter
(integer) 102
&gt; incrby counter 50
(integer) 152
</code></pre></div></div>

<p><a href="/commands/incr.html">INCR</a> 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，类似的命令有<a href="/commands/incrby.html">INCRBY</a>, <a href="/commands/decr.html">DECR</a> 和 <a href="/commands/decrby.html">DECRBY</a>。实际上他们在内部就是同一个命令，只是看上去有点儿不同。</p>

<p><a href="/commands/incr.html">INCR</a>是原子操作意味着什么呢？就是说即使多个客户端对同一个key发出<a href="/commands/incr.html">INCR</a>命令，也决不会导致竞争的情况。例如如下情况永远不可能发生：『客户端1和客户端2同时读出“10”，他们俩都对其加到11，然后将新值设置为11』。最终的值一定是12，read-increment-set操作完成时，其他客户端不会在同一时间执行任何命令。</p>

<p>对字符串，另一个的令人感兴趣的操作是<a href="/commands/getset.html">GETSET</a>命令，行如其名：他为key设置新值并且返回原值。这有什么用处呢？例如：你的系统每当有新用户访问时就用<a href="/commands/incr.html">INCR</a>命令操作一个Redis key。你希望每小时对这个信息收集一次。你就可以<a href="/commands/getset.html">GETSET</a>这个key并给其赋值0并读取原值。</p>

<p>为减少等待时间，也可以一次存储或获取多个key对应的值，使用<a href="/commands/mset.html">MSET</a>和<a href="/commands/mget.html">MGET</a>命令:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mset a 10 b 20 c 30
OK
&gt; mget a b c
1) "10"
2) "20"
3) "30"
</code></pre></div></div>

<p>MGET 命令返回由值组成的数组。</p>

<h2 id="修改或查询键空间">修改或查询键空间</h2>

<p>有些指令不是针对任何具体的类型定义的，而是用于和整个键空间交互的。因此，它们可被用于任何类型的键。</p>

<p>使用EXISTS命令返回1或0标识给定key的值是否存在，使用<a href="/commands/del.html">DEL</a>命令可以删除key对应的值，DEL命令返回1或0标识值是被删除(值存在)或者没被删除(key对应的值不存在)。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; set mykey hello
OK
&gt; exists mykey
(integer) 1
&gt; del mykey
(integer) 1
&gt; exists mykey
(integer) 0
</code></pre></div></div>

<p><a href="/commands/type.html">TYPE</a>命令可以返回key对应的值的存储类型：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; set mykey x
OK
&gt; type mykey
string
&gt; del mykey
(integer) 1
&gt; type mykey
none
</code></pre></div></div>

<h2 id="redis超时数据在限定时间内存活">Redis超时:数据在限定时间内存活</h2>

<p>在介绍复杂类型前我们先介绍一个与值类型无关的Redis特性:超时。你可以对key设置一个超时时间，当这个时间到达后会被删除。精度可以使用毫秒或秒。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; set key some-value
OK
&gt; expire key 5
(integer) 1
&gt; get key (immediately)
"some-value"
&gt; get key (after some time)
(nil)
</code></pre></div></div>

<p>上面的例子使用了EXPIRE来设置超时时间(也可以再次调用这个命令来改变超时时间，使用PERSIST命令去除超时时间 )。我们也可以在创建值的时候设置超时时间:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; set key 100 ex 10
OK
&gt; ttl key
(integer) 9
</code></pre></div></div>

<p>TTL命令用来查看key对应的值剩余存活时间。</p>

<h2 id="redis-lists">Redis Lists</h2>

<p>要说清楚列表数据类型，最好先讲一点儿理论背景，在信息技术界List这个词常常被使用不当。例如”Python Lists”就名不副实（名为Linked Lists），但他们实际上是数组（同样的数据类型在Ruby中叫数组）</p>

<p>一般意义上讲，列表就是有序元素的序列：10,20,1,2,3就是一个列表。但用数组实现的List和用Linked List实现的List，在属性方面大不相同。</p>

<p>Redis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。</p>

<p>那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。</p>

<p>Redis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。</p>

<p>如果快速访问集合元素很重要，建议使用可排序集合(sorted sets)。可排序集合我们会随后介绍。</p>

<h2 id="redis-lists-入门">Redis lists 入门</h2>

<p><a href="/commands/lpush.html">LPUSH</a> 命令可向list的左边（头部）添加一个新元素，而<a href="/commands/rpush.html">RPUSH</a>命令可向list的右边（尾部）添加一个新元素。最后<a href="/commands/lrange.html">LRANGE</a> 命令可从list中取出一定范围的元素:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; rpush mylist A
(integer) 1
&gt; rpush mylist B
(integer) 2
&gt; lpush mylist first
(integer) 3
&gt; lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
</code></pre></div></div>

<p>注意:<a href="/commands/lrange.html">LRANGE</a> 带有两个索引，一定范围的第一个和最后一个元素。这两个索引都可以为负来告知Redis从尾部开始计数，因此-1表示最后一个元素，-2表示list中的倒数第二个元素，以此类推。</p>

<p>上面的所有命令的参数都可变，方便你一次向list存入多个值。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; rpush mylist 1 2 3 4 5 "foo bar"
(integer) 9
&gt; lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
4) "1"
5) "2"
6) "3"
7) "4"
8) "5"
9) "foo bar"
</code></pre></div></div>

<p>还有一个重要的命令是pop,它从list中删除元素并同时返回删除的值。可以在左边或右边操作。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; rpush mylist a b c
(integer) 3
&gt; rpop mylist
"c"
&gt; rpop mylist
"b"
&gt; rpop mylist
"a"
</code></pre></div></div>

<p>我们增加了三个元素，并弹出了三个元素，因此，在这最后
列表中的命令序列是空的，没有更多的元素可以被弹出。如果我们尝试弹出另一个元素，这是我们得到的结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; rpop mylist
(nil)
</code></pre></div></div>

<p>当list没有元素时，Redis 返回了一个NULL。</p>

<h2 id="list的常用案例">List的常用案例</h2>

<p>正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。</p>

<p>例如在评级系统中，比如社会化新闻网站 reddit.com，你可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。</p>

<p>在博客引擎实现中，你可为每篇日志设置一个list，在该list中推入博客评论，等等。</p>

<h2 id="capped-lists">Capped lists</h2>

<p>可以使用<a href="/commands/ltrim.html">LTRIM</a>把list从左边截取指定长度。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; rpush mylist 1 2 3 4 5
(integer) 5
&gt; ltrim mylist 0 2
OK
&gt; lrange mylist 0 -1
1) "1"
2) "2"
3) "3"
</code></pre></div></div>

<h2 id="list上的阻塞操作">List上的阻塞操作</h2>

<p>可以使用Redis来实现生产者和消费者模型，如使用LPUSH和RPOP来实现该功能。但会遇到这种情景：list是空，这时候消费者就需要轮询来获取数据，这样就会增加redis的访问压力、增加消费端的cpu时间，而很多访问都是无用的。为此redis提供了阻塞式访问 <a href="/commands/brpop.html">BRPOP</a> 和 <a href="/commands/blpop.html">BLPOP</a> 命令。 消费者可以在获取数据时指定如果数据不存在阻塞的时间，如果在时限内获得数据则立即返回，如果超时还没有数据则返回null, 0表示一直阻塞。</p>

<p>同时redis还会为所有阻塞的消费者以先后顺序排队。</p>

<p>如需了解详细信息请查看 <a href="/commands/rpoplpush.html">RPOPLPUSH</a> 和 <a href="/commands/brpoplpush.html">BRPOPLPUSH</a>。</p>

<h2 id="key-的自动创建和删除">key 的自动创建和删除</h2>

<p>目前为止，在我们的例子中，我们没有在推入元素之前创建空的 list，或者在 list 没有元素时删除它。在 list 为空时删除 key，并在用户试图添加元素（比如通过 <code class="language-plaintext highlighter-rouge">LPUSH</code>）而键不存在时创建空 list，是 Redis 的职责。</p>

<p>这不光适用于 lists，还适用于所有包括多个元素的 Redis 数据类型 – Sets, Sorted Sets 和 Hashes。</p>

<p>基本上，我们可以用三条规则来概括它的行为：</p>

<ol>
  <li>当我们向一个聚合数据类型中添加元素时，如果目标键不存在，就在添加元素前创建空的聚合数据类型。</li>
  <li>当我们从聚合数据类型中移除元素时，如果值仍然是空的，键自动被销毁。</li>
  <li>对一个空的 key 调用一个只读的命令，比如 <code class="language-plaintext highlighter-rouge">LLEN</code> （返回 list 的长度），或者一个删除元素的命令，将总是产生同样的结果。该结果和对一个空的聚合类型做同个操作的结果是一样的。</li>
</ol>

<p>规则 1 示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; del mylist
(integer) 1
&gt; lpush mylist 1 2 3
(integer) 3
</code></pre></div></div>

<p>但是，我们不能对存在但类型错误的 key 做操作：
    &gt; set foo bar
    OK
    &gt; lpush foo 1 2 3
    (error) WRONGTYPE Operation against a key holding the wrong kind of value
    &gt; type foo
    string</p>

<p>规则 2 示例:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; lpush mylist 1 2 3
(integer) 3
&gt; exists mylist
(integer) 1
&gt; lpop mylist
"3"
&gt; lpop mylist
"2"
&gt; lpop mylist
"1"
&gt; exists mylist
(integer) 0
</code></pre></div></div>

<p>所有的元素被弹出之后， key 不复存在。</p>

<p>规则 3 示例:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; del mylist
(integer) 0
&gt; llen mylist
(integer) 0
&gt; lpop mylist
(nil)
</code></pre></div></div>

<p><a name="hashes"></a>
Redis Hashes
—</p>

<p>Redis hash 看起来就像一个 “hash” 的样子，由键值对组成：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; hmset user:1000 username antirez birthyear 1977 verified 1
OK
&gt; hget user:1000 username
"antirez"
&gt; hget user:1000 birthyear
"1977"
&gt; hgetall user:1000
1) "username"
2) "antirez"
3) "birthyear"
4) "1977"
5) "verified"
6) "1"
</code></pre></div></div>

<p>Hash 便于表示 <em>objects</em>，实际上，你可以放入一个 hash 的域数量实际上没有限制（除了可用内存以外）。所以，你可以在你的应用中以不同的方式使用 hash。</p>

<p><code class="language-plaintext highlighter-rouge">HMSET</code> 指令设置 hash 中的多个域，而 <code class="language-plaintext highlighter-rouge">HGET</code> 取回单个域。<code class="language-plaintext highlighter-rouge">HMGET</code> 和 <code class="language-plaintext highlighter-rouge">HGET</code> 类似，但返回一系列值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; hmget user:1000 username birthyear no-such-field
1) "antirez"
2) "1977"
3) (nil)
</code></pre></div></div>

<p>也有一些指令能够对单独的域执行操作，比如 <code class="language-plaintext highlighter-rouge">HINCRBY</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; hincrby user:1000 birthyear 10
(integer) 1987
&gt; hincrby user:1000 birthyear 10
(integer) 1997
</code></pre></div></div>

<p>你可以在文档中找到 <a href="http://redis.io/commands#hash">hash 指令的完整列表</a>。</p>

<p>值得注意的是，小的 hash 被用特殊方式编码，非常节约内存。</p>

<p><a name="sets"></a>
Redis Sets
—</p>

<p>Redis Set 是 String 的无序排列。<code class="language-plaintext highlighter-rouge">SADD</code> 指令把新的元素添加到 set 中。对 set 也可做一些其他的操作，比如测试一个给定的元素是否存在，对不同 set 取交集，并集或差，等等。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; sadd myset 1 2 3
(integer) 3
&gt; smembers myset
1. 3
2. 1
3. 2
</code></pre></div></div>

<p>现在我已经把三个元素加到我的 set 中，并告诉 Redis 返回所有的元素。可以看到，它们没有被排序 —— Redis 在每次调用时可能按照任意顺序返回元素，因为对于元素的顺序并没有规定。</p>

<p>Redis 有检测成员的指令。一个特定的元素是否存在？</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; sismember myset 3
(integer) 1
&gt; sismember myset 30
(integer) 0
</code></pre></div></div>

<p>“3” 是 set 的一个成员，而 “30” 不是。</p>

<p>Sets 适合用于表示对象间的关系。
例如，我们可以轻易使用 set 来表示标记。</p>

<p>一个简单的建模方式是，对每一个希望标记的对象使用 set。这个 set 包含和对象相关联的标签的 ID。</p>

<p>假设我们想要给新闻打上标签。
假设新闻 ID 1000 被打上了 1,2,5 和 77 四个标签，我们可以使用一个 set 把 tag ID 和新闻条目关联起来：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; sadd news:1000:tags 1 2 5 77
(integer) 4
</code></pre></div></div>

<p>但是，有时候我可能也会需要相反的关系：所有被打上相同标签的新闻列表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; sadd tag:1:news 1000
(integer) 1
&gt; sadd tag:2:news 1000
(integer) 1
&gt; sadd tag:5:news 1000
(integer) 1
&gt; sadd tag:77:news 1000
(integer) 1
</code></pre></div></div>

<p>获取一个对象的所有 tag 是很方便的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; smembers news:1000:tags
1. 5
2. 1
3. 77
4. 2
</code></pre></div></div>

<p>注意：在这个例子中，我们假设你有另一个数据结构，比如一个 Redis hash，把标签 ID 对应到标签名称。</p>

<p>使用 Redis 命令行，我们可以轻易实现其它一些有用的操作。比如，我们可能需要一个含有 1, 2, 10, 和 27 标签的对象的列表。我们可以用 <code class="language-plaintext highlighter-rouge">SINTER</code> 命令来完成这件事。它获取不同 set 的交集。我们可以用：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; sinter tag:1:news tag:2:news tag:10:news tag:27:news
... results here ...
</code></pre></div></div>

<p>不光可以取交集，还可以取并集，差集，获取随机元素，等等。</p>

<p>获取一个元素的命令是 <code class="language-plaintext highlighter-rouge">SPOP</code>，它很适合对特定问题建模。比如，要实现一个基于 web 的扑克游戏，你可能需要用 set 来表示一副牌。假设我们用一个字符的前缀来表示不同花色：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
   D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3
   H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6
   S7 S8 S9 S10 SJ SQ SK
   (integer) 52
</code></pre></div></div>

<p>现在，我们想要给每个玩家 5 张牌。<code class="language-plaintext highlighter-rouge">SPOP</code> 命令删除一个随机元素，把它返回给客户端，因此它是完全合适的操作。</p>

<p>但是，如果我们对我们的牌直接调用它，在下一盘我们就需要重新充满这副牌。开始，我们可以复制 <code class="language-plaintext highlighter-rouge">deck</code> 键中的内容，并放入 <code class="language-plaintext highlighter-rouge">game:1:deck</code> 键中。</p>

<p>这是通过 <code class="language-plaintext highlighter-rouge">SUNIONSTORE</code> 实现的，它通常用于对多个集合取并集，并把结果存入另一个 set 中。但是，因为一个 set 的并集就是它本身，我可以这样复制我的牌：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; sunionstore game:1:deck deck
(integer) 52
</code></pre></div></div>

<p>现在，我已经准备好给 1 号玩家发五张牌：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; spop game:1:deck
"C6"
&gt; spop game:1:deck
"CQ"
&gt; spop game:1:deck
"D1"
&gt; spop game:1:deck
"CJ"
&gt; spop game:1:deck
"SJ"
</code></pre></div></div>

<p>One pair of jacks, not great…</p>

<p>Now it’s a good time to introduce the set command that provides the number
of elements inside a set. This is often called the <em>cardinality of a set</em>
in the context of set theory, so the Redis command is called <code class="language-plaintext highlighter-rouge">SCARD</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; scard game:1:deck
(integer) 47
</code></pre></div></div>

<p>The math works: 52 - 5 = 47.</p>

<p>When you need to just get random elements without removing them from the
set, there is the <code class="language-plaintext highlighter-rouge">SRANDMEMBER</code> command suitable for the task. It also features
the ability to return both repeating and non-repeating elements.</p>

<p><a name="sorted-sets"></a>
Redis Sorted sets
—</p>

<p>Sorted sets are a data type which is similar to a mix between a Set and
a Hash. Like sets, sorted sets are composed of unique, non-repeating
string elements, so in some sense a sorted set is a set as well.</p>

<p>However while elements inside sets are not ordered, every element in
a sorted set is associated with a floating point value, called <em>the score</em>
(this is why the type is also similar to a hash, since every element
is mapped to a value).</p>

<p>Moreover, elements in a sorted sets are <em>taken in order</em> (so they are not
ordered on request, order is a peculiarity of the data structure used to
represent sorted sets). They are ordered according to the following rule:</p>

<ul>
  <li>If A and B are two elements with a different score, then A &gt; B if A.score is &gt; B.score.</li>
  <li>If A and B have exactly the same score, then A &gt; B if the A string is lexicographically greater than the B string. A and B strings can’t be equal since sorted sets only have unique elements.</li>
</ul>

<p>Let’s start with a simple example, adding a few selected hackers names as
sorted set elements, with their year of birth as “score”.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zadd hackers 1940 "Alan Kay"
(integer) 1
&gt; zadd hackers 1957 "Sophie Wilson"
(integer 1)
&gt; zadd hackers 1953 "Richard Stallman"
(integer) 1
&gt; zadd hackers 1949 "Anita Borg"
(integer) 1
&gt; zadd hackers 1965 "Yukihiro Matsumoto"
(integer) 1
&gt; zadd hackers 1914 "Hedy Lamarr"
(integer) 1
&gt; zadd hackers 1916 "Claude Shannon"
(integer) 1
&gt; zadd hackers 1969 "Linus Torvalds"
(integer) 1
&gt; zadd hackers 1912 "Alan Turing"
(integer) 1
</code></pre></div></div>

<p>As you can see <code class="language-plaintext highlighter-rouge">ZADD</code> is similar to <code class="language-plaintext highlighter-rouge">SADD</code>, but takes one additional argument
(placed before the element to be added) which is the score.
<code class="language-plaintext highlighter-rouge">ZADD</code> is also variadic, so you are free to specify multiple score-value
pairs, even if this is not used in the example above.</p>

<p>With sorted sets it is trivial to return a list of hackers sorted by their
birth year because actually <em>they are already sorted</em>.</p>

<p>Implementation note: Sorted sets are implemented via a
dual-ported data structure containing both a skip list and a hash table, so
every time we add an element Redis performs an O(log(N)) operation. That’s
good, but when we ask for sorted elements Redis does not have to do any work at
all, it’s already all sorted:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zrange hackers 0 -1
1) "Alan Turing"
2) "Hedy Lamarr"
3) "Claude Shannon"
4) "Alan Kay"
5) "Anita Borg"
6) "Richard Stallman"
7) "Sophie Wilson"
8) "Yukihiro Matsumoto"
9) "Linus Torvalds"
</code></pre></div></div>

<p>Note: 0 and -1 means from element index 0 to the last element (-1 works
here just as it does in the case of the <code class="language-plaintext highlighter-rouge">LRANGE</code> command).</p>

<p>What if I want to order them the opposite way, youngest to oldest?
Use <a href="/commands/zrevrange">ZREVRANGE</a> instead of <a href="/commands/zrange">ZRANGE</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zrevrange hackers 0 -1
1) "Linus Torvalds"
2) "Yukihiro Matsumoto"
3) "Sophie Wilson"
4) "Richard Stallman"
5) "Anita Borg"
6) "Alan Kay"
7) "Claude Shannon"
8) "Hedy Lamarr"
9) "Alan Turing"
</code></pre></div></div>

<p>It is possible to return scores as well, using the <code class="language-plaintext highlighter-rouge">WITHSCORES</code> argument:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zrange hackers 0 -1 withscores
1) "Alan Turing"
2) "1912"
3) "Hedy Lamarr"
4) "1914"
5) "Claude Shannon"
6) "1916"
7) "Alan Kay"
8) "1940"
9) "Anita Borg"
10) "1949"
11) "Richard Stallman"
12) "1953"
13) "Sophie Wilson"
14) "1957"
15) "Yukihiro Matsumoto"
16) "1965"
17) "Linus Torvalds"
18) "1969"
</code></pre></div></div>

<h2 id="operating-on-ranges">Operating on ranges</h2>

<p>Sorted sets are more powerful than this. They can operate on ranges.
Let’s get all the individuals that were born up to 1950 inclusive. We
use the <code class="language-plaintext highlighter-rouge">ZRANGEBYSCORE</code> command to do it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zrangebyscore hackers -inf 1950
1) "Alan Turing"
2) "Hedy Lamarr"
3) "Claude Shannon"
4) "Alan Kay"
5) "Anita Borg"
</code></pre></div></div>

<p>We asked Redis to return all the elements with a score between negative
infinity and 1950 (both extremes are included).</p>

<p>It’s also possible to remove ranges of elements. Let’s remove all
the hackers born between 1940 and 1960 from the sorted set:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zremrangebyscore hackers 1940 1960
(integer) 4
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ZREMRANGEBYSCORE</code> is perhaps not the best command name,
but it can be very useful, and returns the number of removed elements.</p>

<p>Another extremely useful operation defined for sorted set elements
is the get-rank operation. It is possible to ask what is the
position of an element in the set of the ordered elements.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zrank hackers "Anita Borg"
(integer) 4
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ZREVRANK</code> command is also available in order to get the rank, considering
the elements sorted a descending way.</p>

<h2 id="lexicographical-scores">Lexicographical scores</h2>

<p>With recent versions of Redis 2.8, a new feature was introduced that allows
getting ranges lexicographically, assuming elements in a sorted set are all
inserted with the same identical score (elements are compared with the C
<code class="language-plaintext highlighter-rouge">memcmp</code> function, so it is guaranteed that there is no collation, and every
Redis instance will reply with the same output).</p>

<p>The main commands to operate with lexicographical ranges are <code class="language-plaintext highlighter-rouge">ZRANGEBYLEX</code>,
<code class="language-plaintext highlighter-rouge">ZREVRANGEBYLEX</code>, <code class="language-plaintext highlighter-rouge">ZREMRANGEBYLEX</code> and <code class="language-plaintext highlighter-rouge">ZLEXCOUNT</code>.</p>

<p>For example, let’s add again our list of famous hackers, but this time
use a score of zero for all the elements:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zadd hackers 0 "Alan Kay" 0 "Sophie Wilson" 0 "Richard Stallman" 0
  "Anita Borg" 0 "Yukihiro Matsumoto" 0 "Hedy Lamarr" 0 "Claude Shannon"
  0 "Linus Torvalds" 0 "Alan Turing"
</code></pre></div></div>

<p>Because of the sorted sets ordering rules, they are already sorted
lexicographically:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zrange hackers 0 -1
1) "Alan Kay"
2) "Alan Turing"
3) "Anita Borg"
4) "Claude Shannon"
5) "Hedy Lamarr"
6) "Linus Torvalds"
7) "Richard Stallman"
8) "Sophie Wilson"
9) "Yukihiro Matsumoto"
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">ZRANGEBYLEX</code> we can ask for lexicographical ranges:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; zrangebylex hackers [B [P
1) "Claude Shannon"
2) "Hedy Lamarr"
3) "Linus Torvalds"
</code></pre></div></div>

<p>Ranges can be inclusive or exclusive (depending on the first character),
also string infinite and minus infinite are specified respectively with
the <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">-</code> strings. See the documentation for more information.</p>

<p>This feature is important because it allows us to use sorted sets as a generic
index. For example, if you want to index elements by a 128-bit unsigned
integer argument, all you need to do is to add elements into a sorted
set with the same score (for example 0) but with an 8 byte prefix
consisting of <strong>the 128 bit number in big endian</strong>. Since numbers in big
endian, when ordered lexicographically (in raw bytes order) are actually
ordered numerically as well, you can ask for ranges in the 128 bit space,
and get the element’s value discarding the prefix.</p>

<p>If you want to see the feature in the context of a more serious demo,
check the <a href="http://autocomplete.redis.io">Redis autocomplete demo</a>.</p>

<h2 id="updating-the-score-leader-boards">Updating the score: leader boards</h2>

<p>Just a final note about sorted sets before switching to the next topic.
Sorted sets’ scores can be updated at any time. Just calling <code class="language-plaintext highlighter-rouge">ZADD</code> against
an element already included in the sorted set will update its score
(and position) with O(log(N)) time complexity.  As such, sorted sets are suitable
when there are tons of updates.</p>

<p>Because of this characteristic a common use case is leader boards.
The typical application is a Facebook game where you combine the ability to
take users sorted by their high score, plus the get-rank operation, in order
to show the top-N users, and the user rank in the leader board (e.g., “you are
the #4932 best score here”).</p>

<p><a name="bitmaps"></a>
Bitmaps
—</p>

<p>Bitmaps are not an actual data type, but a set of bit-oriented operations
defined on the String type. Since strings are binary safe blobs and their
maximum length is 512 MB, they are suitable to set up to 2^32 different
bits.</p>

<p>Bit operations are divided into two groups: constant-time single bit
operations, like setting a bit to 1 or 0, or getting its value, and
operations on groups of bits, for example counting the number of set
bits in a given range of bits (e.g., population counting).</p>

<p>One of the biggest advantages of bitmaps is that they often provide
extreme space savings when storing information. For example in a system
where different users are represented by incremental user IDs, it is possible
to remember a single bit information (for example, knowing whether
a user wants to receive a newsletter) of 4 billion of users using just 512 MB of memory.</p>

<p>Bits are set and retrieved using the <code class="language-plaintext highlighter-rouge">SETBIT</code> and <code class="language-plaintext highlighter-rouge">GETBIT</code> commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; setbit key 10 1
(integer) 1
&gt; getbit key 10
(integer) 1
&gt; getbit key 11
(integer) 0
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">SETBIT</code> command takes as its first argument the bit number, and as its second
argument the value to set the bit to, which is 1 or 0. The command
automatically enlarges the string if the addressed bit is outside the
current string length.</p>

<p><code class="language-plaintext highlighter-rouge">GETBIT</code> just returns the value of the bit at the specified index.
Out of range bits (addressing a bit that is outside the length of the string
stored into the target key) are always considered to be zero.</p>

<p>There are three commands operating on group of bits:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">BITOP</code> performs bit-wise operations between different strings. The provided operations are AND, OR, XOR and NOT.</li>
  <li><code class="language-plaintext highlighter-rouge">BITCOUNT</code> performs population counting, reporting the number of bits set to 1.</li>
  <li><code class="language-plaintext highlighter-rouge">BITPOS</code> finds the first bit having the specified value of 0 or 1.</li>
</ol>

<p>Both <code class="language-plaintext highlighter-rouge">BITPOS</code> and <code class="language-plaintext highlighter-rouge">BITCOUNT</code> are able to operate with byte ranges of the
string, instead of running for the whole length of the string. The following
is a trivial example of <code class="language-plaintext highlighter-rouge">BITCOUNT</code> call:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; setbit key 0 1
(integer) 0
&gt; setbit key 100 1
(integer) 0
&gt; bitcount key
(integer) 2
</code></pre></div></div>

<p>Common user cases for bitmaps are:</p>

<ul>
  <li>Real time analytics of all kinds.</li>
  <li>Storing space efficient but high performance boolean information associated with object IDs.</li>
</ul>

<p>For example imagine you want to know the longest streak of daily visits of
your web site users. You start counting days starting from zero, that is the
day you made your web site public, and set a bit with <code class="language-plaintext highlighter-rouge">SETBIT</code> every time
the user visits the web site. As a bit index you simply take the current unix
time, subtract the initial offset, and divide by 3600*24.</p>

<p>This way for each user you have a small string containing the visit
information for each day. With <code class="language-plaintext highlighter-rouge">BITCOUNT</code> it is possible to easily get
the number of days a given user visited the web site, while with
a few <code class="language-plaintext highlighter-rouge">BITPOS</code> calls, or simply fetching and analyzing the bitmap client-side,
it is possible to easily compute the longest streak.</p>

<p>Bitmaps are trivial to split into multiple keys, for example for
the sake of sharding the data set and because in general it is better to
avoid working with huge keys. To split a bitmap across different keys
instead of setting all the bits into a key, a trivial strategy is just
to store M bits per key and obtain the key name with <code class="language-plaintext highlighter-rouge">bit-number/M</code> and
the Nth bit to address inside the key with <code class="language-plaintext highlighter-rouge">bit-number MOD M</code>.</p>

<p><a name="hyperloglogs"></a>
HyperLogLogs
—</p>

<p>A HyperLogLog is a probabilistic data structure used in order to count
unique things (technically this is referred to estimating the cardinality
of a set). Usually counting unique items requires using an amount of memory
proportional to the number of items you want to count, because you need
to remember the elements you have already seen in the past in order to avoid
counting them multiple times. However there is a set of algorithms that trade
memory for precision: you end with an estimated measure with a standard error,
in the case of the Redis implementation, which is less than 1%.  The
magic of this algorithm is that you no longer need to use an amount of memory
proportional to the number of items counted, and instead can use a
constant amount of memory! 12k bytes in the worst case, or a lot less if your
HyperLogLog (We’ll just call them HLL from now) has seen very few elements.</p>

<p>HLLs in Redis, while technically a different data structure, is encoded
as a Redis string, so you can call <code class="language-plaintext highlighter-rouge">GET</code> to serialize a HLL, and <code class="language-plaintext highlighter-rouge">SET</code>
to deserialize it back to the server.</p>

<p>Conceptually the HLL API is like using Sets to do the same task. You would
<code class="language-plaintext highlighter-rouge">SADD</code> every observed element into a set, and would use <code class="language-plaintext highlighter-rouge">SCARD</code> to check the
number of elements inside the set, which are unique since <code class="language-plaintext highlighter-rouge">SADD</code> will not
re-add an existing element.</p>

<p>While you don’t really <em>add items</em> into an HLL, because the data structure
only contains a state that does not include actual elements, the API is the
same:</p>

<ul>
  <li>Every time you see a new element, you add it to the count with <code class="language-plaintext highlighter-rouge">PFADD</code>.</li>
  <li>
    <p>Every time you want to retrieve the current approximation of the unique elements <em>added</em> with <code class="language-plaintext highlighter-rouge">PFADD</code> so far, you use the <code class="language-plaintext highlighter-rouge">PFCOUNT</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt; pfadd hll a b c d
  (integer) 1
  &gt; pfcount hll
  (integer) 4
</code></pre></div>    </div>
  </li>
</ul>

<p>An example of use case for this data structure is counting unique queries
performed by users in a search form every day.</p>

<p>Redis is also able to perform the union of HLLs, please check the
<a href="/commands#hyperloglog">full documentation</a> for more information.</p>

<h2 id="other-notable-features">Other notable features</h2>

<p>There are other important things in the Redis API that can’t be explored
in the context of this document, but are worth your attention:</p>

<ul>
  <li>It is possible to <a href="/commands/scan">iterate the key space of a large collection incrementally</a>.</li>
  <li>It is possible to run <a href="/commands/eval">Lua scripts server side</a> to win latency and bandwidth.</li>
  <li>Redis is also a <a href="/topics/pubsub">Pub-Sub server</a>.</li>
</ul>

<h2 id="learn-more">Learn more</h2>

<p>This tutorial is in no way complete and has covered just the basics of the API.
Read the <a href="/commands">command reference</a> to discover a lot more.</p>

<p>Thanks for reading, and have fun hacking with Redis!</p>

	</article>
	
</div>
<script>
		if(isRediscnPc()){
			var s = "_" + Math.random().toString(36).slice(2);
			document.write('<div style="margin-bottom:10px;" id="' + s + '"></div>');
			(window.slotbydup = window.slotbydup || []).push({
				id: "u3556359",
				container:  s
			});
			document.write('<scr'+'ipt type="text/javascr'+'ipt" src="//cpro.baidustatic.com/cpro/ui/c.js" async="async" defer="defer" ></scr'+'ipt>');
		}
	
</script>
<footer class='site-footer'>
        <div class='container'>
          本站资源翻译自<a href="http://redis.io" target="_blank">redis.io</a>，
					由<a src="./aboutus.html">redis.cn翻译团队</a>翻译，
					更新日志请点击<a src="./update.html">这里</a>查看，
					翻译原文版权归redis.io官方所有，翻译不正确的地方欢迎大家指出。<br> 
					感谢各界爱心人士的热心捐赠，CRUG的成长离不开大家的帮助和支持，特别是<a src="./donation.html">Redis捐赠清单</a>里面的各位伙伴。<br>
					联系Email:<a href="mailto:admin@redis.cn">admin@redis.cn</a>，
					redis交流群：<a href="#">579708237</a> &nbsp; 
					<a href="https://beian.miit.gov.cn" target="_blank">京ICP备15003959号-2</a> &nbsp;
					<br>    
					<span style="font-weight:bold;color:#000000;">友情链接：</span>
					<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=fvilu0rm" target="_blank">阿里云</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">DBA的罗浮宫</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">VIP-陈群博客</a> &nbsp;
					<a href="http://lib.csdn.net/base/redis" target="_blank">Redis-知识库</a> &nbsp;
					<a href="http://www.kubernetes.org.cn" target="_blank" >Kubernetes</a> &nbsp;	
					<a href="https://www.fanghouguo.com" target="_blank" >方后国的博客</a> &nbsp;	
					<a href="https://aff.gae1s.com/aff.php?aff=10022" target="_blank" >ChromeGAE</a> &nbsp;	
					<a href="http://top.chinaz.com/" target="_blank" >网站排行榜</a> &nbsp;	
        </div>
      </footer>
    </div>
  </body>
</html>


<script>
	if(!isMobileBrowser()){
		window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"0","bdPos":"right","bdTop":"54.5"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	}
</script>

<script type='text/javascript'>
lastScrollY=0;

function heartBeat(){ 
	var diffY;
	if (document.documentElement && document.documentElement.scrollTop)
	diffY = document.documentElement.scrollTop;
	else if (document.body)
	diffY = document.body.scrollTop
	else
	{/*Netscape stuff*/}
	//alert(diffY);
	percent=.1*(diffY-lastScrollY); 
	if(percent>0)percent=Math.ceil(percent); 
	else percent=Math.floor(percent); 
	document.getElementById("lovexin12").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	document.getElementById("lovexin14").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	lastScrollY=lastScrollY+percent; 
	//alert(lastScrollY);
}

if(!isMobileBrowser()){
		//suspendcode12="<DIV id=\"lovexin12\" style='width:120px;height:270px;left:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://bbs.huaweicloud.com/forum/thread-16526-1-1.html' target='_blank'><img src='./images/couplets/hw_cp_20190411_01.png'/></a></div>"
		//suspendcode14="<DIV id=\"lovexin14\" style='width:120px;height:270px;right:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://activity.huaweicloud.com/2019june_promotion/index.html?utm_source=huawei&utm_medium=other&utm_campaign=618dacu&utm_content=0614#app-connection' target='_blank'><img src='./images/couplets/hw_cp_20190612.png'/></a></div>"
		//document.write(suspendcode12); 
		//document.write(suspendcode14); 
		//window.setInterval("heartBeat()",1);
}

$(document).ready(function(){ 
	
});
</script>
