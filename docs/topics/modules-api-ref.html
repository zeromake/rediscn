<!DOCTYPE html>
<html>
	<head>
    <meta charset='utf-8' />
    <link rel="stylesheet" href="/css/styles.css?1436966512">
    <link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href='./images/favicon.png' rel='shortcut icon' />
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>modules-api-ref -- Redis中国用户组（CRUG）</title>
    <meta name="description" content="redis
">
		<script src='./js/jquery-2.0.3.min.js?1426205838'></script>
		<script src='./js/slideout.js?1426205838'></script>
		<script src='./js/app.js?1436878127'></script>
		<script src='./js/base.js?1436878127'></script>
  </head>

<body class=''>
    <div class='mobile-menu slideout-menu'>
      <header class='menu-header'></header>
      <section class='menu-section'>
        <ul class='menu-section-list'>
          <li>
            <a class='home' src='/'>首页</a>
          </li>
          <li>
            <a href='./commands.html'>命令</a>
          </li>
          <li>
            <a href='./clients.html'>客户端</a>
          </li>
          <li>
            <a href='./documentation.html'>文档</a>
          </li>
          <li>
            <a href='./community.html'>社区</a>
          </li>
          <li>
            <a href='./download.html'>下载</a>
          </li>
          <li>
            <a href='./support.html'>支持</a>
          </li>
          <li>
            <a href='./topics/license.html'>许可</a>
          </li>
          <li>
            <a href='./update.html'>更新日志</a>
          </li>
          <li>
            <a href='./articles.html'>文章大全</a>
          </li>
		  <li>
            <a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </li>
          
        </ul>
      </section>
    </div>
    <div class='site-wrapper'>
      <header class='site-header'>
        <nav class='container'>
          <div class='mobile-header'>
            <button class='btn-hamburger js-slideout-toggle'>
              <span class='fa fa-bars'></span>
            </button>
            <a class='home' src='/'>
              <img alt='Redis' src='./images/redis-white.png' />
            </a>
          </div>
          <div class='desktop-header'>
            <a class='home' src='/'>
              <img alt='Redis' src='./images/redis-white.png' />
            </a>
            <a href='./commands.html'>命令</a>
            <a href='./clients.html'>客户端</a>
            <a href='./documentation.html'>文档</a>
            <a href='./community.html'>社区</a>
            <a href='./download.html'>下载</a>
            <a href='./support.html'>支持</a>
            <a href='./topics/license.html'>许可</a>
            <a href='./update.html'>更新日志</a>
            <a href='./articles.html'>文章大全</a>
			<a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </div>
        </nav>
      </header>
      <header class='site-header' style="background-color: #ffffff;">
        <!--
        <nav class='container'>
        	<a href="https://activity.huaweicloud.com/support_plan/index.html?utm_source=huawei&utm_medium=banner&utm_campaign=armredis&utm_content=0624&utm_term=crug" target="_blank">
				<img src="./images/bn/huawei_redis_08.png" style="width:100%;"/>
			</a>
        </nav>
      -->
      </header>
      <div class='site-content'>
<div class='text'>
	<article id='topic'>
		<h1 id="modules-api-reference">Modules API reference</h1>

<h2 id="redismodule_alloc"><code class="language-plaintext highlighter-rouge">RedisModule_Alloc</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *RedisModule_Alloc(size_t bytes);
</code></pre></div></div>

<p>Use like malloc(). Memory allocated with this function is reported in
Redis INFO memory, used for keys eviction according to maxmemory settings
and in general is taken into account as memory allocated by Redis.
You should avoid using malloc().
用法同malloc()。Redis 会根据最大内存设置，做keys的淘汰时会用到该函数，命令INFO memory 会统计该函数分配的内存。
避免使用malloc()函数。</p>
<h2 id="redismodule_calloc"><code class="language-plaintext highlighter-rouge">RedisModule_Calloc</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *RedisModule_Calloc(size_t nmemb, size_t size);
</code></pre></div></div>

<p>Use like calloc(). Memory allocated with this function is reported in
Redis INFO memory, used for keys eviction according to maxmemory settings
and in general is taken into account as memory allocated by Redis.
You should avoid using calloc() directly.
用法同calloc()。Redis 会根据最大内存设置，做keys的淘汰时会用到该函数，命令INFO memory 会统计该函数分配的内存。
避免使用calloc()函数。</p>

<h2 id="redismodule_realloc"><code class="language-plaintext highlighter-rouge">RedisModule_Realloc</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void* RedisModule_Realloc(void *ptr, size_t bytes);
</code></pre></div></div>

<p>Use like realloc() for memory obtained with <code class="language-plaintext highlighter-rouge">RedisModule_Alloc()</code>.
用法同realloc(),针对使用<code class="language-plaintext highlighter-rouge">RedisModule_Alloc()</code>分配的内存</p>
<h2 id="redismodule_free"><code class="language-plaintext highlighter-rouge">RedisModule_Free</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_Free(void *ptr);
</code></pre></div></div>

<p>Use like free() for memory obtained by <code class="language-plaintext highlighter-rouge">RedisModule_Alloc()</code> and
<code class="language-plaintext highlighter-rouge">RedisModule_Realloc()</code>. However you should never try to free with
<code class="language-plaintext highlighter-rouge">RedisModule_Free()</code> memory allocated with malloc() inside your module.
用法同 free()，针对使用<code class="language-plaintext highlighter-rouge">RedisModule_Alloc</code>和<code class="language-plaintext highlighter-rouge">RedisModule_Realloc()</code>分配的内存。切勿调用<code class="language-plaintext highlighter-rouge">RedisModule_Free()</code>释放malloc()分配的内存。</p>
<h2 id="redismodule_strdup"><code class="language-plaintext highlighter-rouge">RedisModule_Strdup</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char *RedisModule_Strdup(const char *str);
</code></pre></div></div>

<p>Like strdup() but returns memory allocated with <code class="language-plaintext highlighter-rouge">RedisModule_Alloc()</code>.
用法同strdup()，不过返回使用<code class="language-plaintext highlighter-rouge">RedisModule_Alloc()</code>分配的内存</p>
<h2 id="redismodule_poolalloc"><code class="language-plaintext highlighter-rouge">RedisModule_PoolAlloc</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *RedisModule_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);
</code></pre></div></div>

<p>Return heap allocated memory that will be freed automatically when the
module callback function returns. Mostly suitable for small allocations
that are short living and must be released when the callback returns
anyway. The returned memory is aligned to the architecture word size
if at least word size bytes are requested, otherwise it is just
aligned to the next power of two, so for example a 3 bytes request is
4 bytes aligned while a 2 bytes request is 2 bytes aligned.
返回分配的堆内存，该段内存会在回调函数返回时被自动释放。当回调函数返回时必须释放的小块内存适合使用该函数申请。
申请的内存会按照计算机字对齐，如果有指定字的字节数，则按指定的对齐，默认按照大于申请内存最小的2的次幂对齐，比如3字节会按照4个字节对齐，
2字节则按照2字节对齐。</p>

<p>There is no realloc style function since when this is needed to use the
pool allocator is not a good idea.
没有对应的realloc 函数，不建议使用realloc操作内存池分配器分配的诶村。
The function returns NULL if <code class="language-plaintext highlighter-rouge">bytes</code> is 0.
<code class="language-plaintext highlighter-rouge">bytes</code> 为0时返回NULL。</p>

<h2 id="redismodule_getapi"><code class="language-plaintext highlighter-rouge">RedisModule_GetApi</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_GetApi(const char *funcname, void **targetPtrPtr);
</code></pre></div></div>

<p>Lookup the requested module API and store the function pointer into the
target pointer. The function returns <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> if there is no such
named API, otherwise <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
查询调用的API模块，并将函数指着保存在目标指针。当没有改API时返回<code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code>,否则返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>。</p>

<p>This function is not meant to be used by modules developer, it is only
used implicitly by including redismodule.h.
该函数不是为模块开发者使用的仅是在包含redismodule.h时隐式可调用。</p>

<h2 id="redismodule_iskeyspositionrequest"><code class="language-plaintext highlighter-rouge">RedisModule_IsKeysPositionRequest</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_IsKeysPositionRequest(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Return non-zero if a module command, that was declared with the
flag “getkeys-api”, is called in a special way to get the keys positions
and not to get executed. Otherwise zero is returned.
当一个标志为“getkeys-api”的模块命令被调用来获得keys的位置还没有被执行时，返回非0值，否则返回0.</p>

<h2 id="redismodule_keyatpos"><code class="language-plaintext highlighter-rouge">RedisModule_KeyAtPos</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_KeyAtPos(RedisModuleCtx *ctx, int pos);
</code></pre></div></div>

<p>When a module command is called in order to obtain the position of
keys, since it was flagged as “getkeys-api” during the registration,
the command implementation checks for this special call using the
<code class="language-plaintext highlighter-rouge">RedisModule_IsKeysPositionRequest()</code> API and uses this function in
order to report keys, like in the following example:
调用模块命令获取keys的位置，如果模块命令在注册阶段被标志为“getkeys-api”,那么它会调用<code class="language-plaintext highlighter-rouge">RedisModule_IsKeysPositionRequest()</code>API并使用
该函数来返回keys位置信息，见如下例子
    if (RedisModule_IsKeysPositionRequest(ctx)) {
        RedisModule_KeyAtPos(ctx,1);
        RedisModule_KeyAtPos(ctx,2);
    }</p>

<p>Note: in the example below the get keys API would not be needed since
 keys are at fixed positions. This interface is only used for commands
 with a more complex structure.
注意：如果keys的位置固定，可忽略例子。因为该结构仅针对需要更复杂结构的命令。</p>
<h2 id="redismodule_createcommand"><code class="language-plaintext highlighter-rouge">RedisModule_CreateCommand</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep);
</code></pre></div></div>

<p>Register a new command in the Redis server, that will be handled by
calling the function pointer ‘func’ using the RedisModule calling
convention. The function returns <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> if the specified command
name is already busy or a set of invalid flags were passed, otherwise
<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> is returned and the new command is registered.
使用该函数对新增redis命令进行注册。如果需要注册的命令正在创建或者部分参数设置错误则返回<code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code>,
否则新增命令注册成功，并返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>

<p>This function must be called during the initialization of the module
inside the <code class="language-plaintext highlighter-rouge">RedisModule_OnLoad()</code> function. Calling this function outside
of the initialization function is not defined.
该函数在调用<code class="language-plaintext highlighter-rouge">RedisModule_OnLoad()</code> 进行模块初始化的过程中被调用，其他阶段调用无效。</p>

<p>The command function type is the following:
命令函数的类型如下：
     int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);</p>

<p>And is supposed to always return <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
正常返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>

<p>The set of flags ‘strflags’ specify the behavior of the command, and should
be passed as a C string compoesd of space separated words, like for
example “write deny-oom”. The set of flags are:
信号量<code class="language-plaintext highlighter-rouge">strflags</code> 限定了命令的操作，用空格隔开的C 字符串组成，例如”write deny-oom”,信号量如下：</p>

<ul>
  <li><strong>“write”</strong>:     The command may modify the data set (it may also read
                 from it).</li>
  <li>
    <p><strong>“write”</strong>:     该命令会修改数据集</p>
  </li>
  <li><strong>“readonly”</strong>:  The command returns data from keys but never writes.</li>
  <li><strong>“readonly”</strong>:  该命令仅返回值，不做修改</li>
  <li><strong>“admin”</strong>:     The command is an administrative command (may change
                 replication or perform similar tasks).</li>
  <li><strong>“admin”</strong>:     管理命令(可以调整复制或类似操作)</li>
  <li><strong>“deny-oom”</strong>:  The command may use additional memory and should be
                 denied during out of memory conditions.</li>
  <li>
    <p><strong>“deny-oom”</strong>:  该命令使用额外内存，在内存超用的场景下应当被拒绝</p>
  </li>
  <li><strong>“deny-script”</strong>:   Don’t allow this command in Lua scripts.</li>
  <li>
    <p><strong>“deny-script”</strong>:   禁止使用Lua 脚本</p>
  </li>
  <li><strong>“allow-loading”</strong>: Allow this command while the server is loading data.
                     Only commands not interacting with the data set
                     should be allowed to run in this mode. If not sure
                     don’t use this flag.</li>
  <li>
    <p><strong>“allow-loading”</strong>: 允许Redis 服务器加载数据时执行该命令，只有不和数据集交互的命令在该模式下被允许执行。否则不设置该信号量。</p>
  </li>
  <li><strong>“pubsub”</strong>:    The command publishes things on Pub/Sub channels.</li>
  <li>
    <p><strong>“pubsub”</strong>:    该命令回想发布/订阅频道里发布内容.</p>
  </li>
  <li><strong>“random”</strong>:    The command may have different outputs even starting
                 from the same input arguments and key values.</li>
  <li>
    <p><strong>“random”</strong>:    该命令接收相同的输入可能会有不同的输出</p>
  </li>
  <li><strong>“allow-stale”</strong>: The command is allowed to run on slaves that don’t
                   serve stale data. Don’t use if you don’t know what
                   this means.</li>
  <li>
    <p><strong>“allow-stale”</strong>: 该命令允许在slave上执行，即使slave提供的数据不一致。</p>
  </li>
  <li><strong>“no-monitor”</strong>: Don’t propoagate the command on monitor. Use this if
                  the command has sensible data among the arguments.</li>
  <li>
    <p><strong>“no-monitor”</strong>: 不监控该命令。如果命令参数有敏感数据可以使用该设置</p>
  </li>
  <li><strong>“fast”</strong>:      The command time complexity is not greater
                 than O(log(N)) where N is the size of the collection or
                 anything else representing the normal scalability
                 issue with the command.</li>
  <li>
    <p><strong>“fast”</strong>:      该命令的时间复杂度应当低于O(log(N)),其中N是集合的大小等</p>
  </li>
  <li>
    <p><strong>“getkeys-api”</strong>: The command implements the interface to return
                   the arguments that are keys. Used when start/stop/step
                   is not enough because of the command syntax.</p>
  </li>
  <li>
    <p><strong>“getkeys-api”</strong>: 该命令实现了返回keys的接口。</p>
  </li>
  <li><strong>“no-cluster”</strong>: The command should not register in Redis Cluster
                  since is not designed to work with it because, for
                  example, is unable to report the position of the
                  keys, programmatically creates key names, or any
                  other reason.</li>
  <li><strong>“no-cluster”</strong>: 该命令不在Redis群集中注册，因为该命令不是为群集设计的。</li>
</ul>

<h2 id="redismodule_setmoduleattribs"><code class="language-plaintext highlighter-rouge">RedisModule_SetModuleAttribs</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver);
</code></pre></div></div>

<p>Called by <code class="language-plaintext highlighter-rouge">RM_Init()</code> to setup the <code class="language-plaintext highlighter-rouge">ctx-&gt;module</code> structure.
<code class="language-plaintext highlighter-rouge">RM_Init()</code>使用该函数安装<code class="language-plaintext highlighter-rouge">ctx-&gt;module</code>结构</p>

<p>This is an internal function, Redis modules developers don’t need
to use it.
该函数是测试函数，Redis模块开发者不需要用该函数</p>

<h2 id="redismodule_milliseconds"><code class="language-plaintext highlighter-rouge">RedisModule_Milliseconds</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>long long RedisModule_Milliseconds(void);
</code></pre></div></div>

<p>Return the current UNIX time in milliseconds.
以毫秒数格式返回当前UNIX时间</p>
<h2 id="redismodule_automemory"><code class="language-plaintext highlighter-rouge">RedisModule_AutoMemory</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_AutoMemory(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Enable automatic memory management. See API.md for more information.
打开自动内存管理。详见API.md</p>

<p>The function must be called as the first function of a command implementation
that wants to use automatic memory.
新增命令如果需要自动内存管理，必须先调用该函数。</p>
<h2 id="redismodule_createstring"><code class="language-plaintext highlighter-rouge">RedisModule_CreateString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);
</code></pre></div></div>

<p>Create a new module string object. The returned string must be freed
with <code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>, unless automatic memory is enabled.
创建一个模块字符串对象。除非打开了自动内存管理，否则返回的字符串必须调用<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>释放
The string is created by copying the <code class="language-plaintext highlighter-rouge">len</code> bytes starting
at <code class="language-plaintext highlighter-rouge">ptr</code>. No reference is retained to the passed buffer.
返回的字符串是从<code class="language-plaintext highlighter-rouge">ptr</code>开始的<code class="language-plaintext highlighter-rouge">len</code>个字节。</p>
<h2 id="redismodule_createstringprintf"><code class="language-plaintext highlighter-rouge">RedisModule_CreateStringPrintf</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...);
</code></pre></div></div>

<p>Create a new module string object from a printf format and arguments.
The returned string must be freed with <code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>, unless
automatic memory is enabled.
创建一个格式化后的模块字符串对象。除非打开了自动内存管理，否则返回的字符串必须调用<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>释放。</p>

<p>The string is created using the sds formatter function sdscatvprintf().
该字符串调用sds格式化函数sdscatvprintf()创建。</p>
<h2 id="redismodule_createstringfromlonglong"><code class="language-plaintext highlighter-rouge">RedisModule_CreateStringFromLongLong</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll);
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">RedisModule_CreatString()</code>, but creates a string starting from a long long
integer instead of taking a buffer and its length.
功能同<code class="language-plaintext highlighter-rouge">RedisModule_CreatString()</code>，不同的地方是该函数接收一个长整型数值，不像<code class="language-plaintext highlighter-rouge">RedisModule_CreatString()</code>需要缓存和缓存长度。
The returned string must be released with <code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code> or by
enabling automatic memory management.
除非打开了自动内存管理，否则返回的字符串必须调用<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>释放。</p>

<h2 id="redismodule_createstringfromstring"><code class="language-plaintext highlighter-rouge">RedisModule_CreateStringFromString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str);
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">RedisModule_CreatString()</code>, but creates a string starting from another
RedisModuleString.
功能同<code class="language-plaintext highlighter-rouge">RedisModule_CreatString()</code>,不过该函数通过其他RedisModuleString创建字符串
The returned string must be released with <code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code> or by
enabling automatic memory management.
除非打开了自动内存管理，否则返回的字符串必须调用<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>释放。</p>
<h2 id="redismodule_freestring"><code class="language-plaintext highlighter-rouge">RedisModule_FreeString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_FreeString(RedisModuleCtx *ctx, RedisModuleString *str);
</code></pre></div></div>

<p>Free a module string object obtained with one of the Redis modules API calls
that return new string objects.
释放通过Redis模块API创建的字符串对象。</p>

<p>It is possible to call this function even when automatic memory management
is enabled. In that case the string will be released ASAP and removed
from the pool of string to release at the end.
即使打开了自动内存管理，也可以调用该函数。只不过调用该函数后字符串会被马上释放，不用等到自动管理函数释放。</p>
<h2 id="redismodule_retainstring"><code class="language-plaintext highlighter-rouge">RedisModule_RetainString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_RetainString(RedisModuleCtx *ctx, RedisModuleString *str);
</code></pre></div></div>

<p>Every call to this function, will make the string ‘str’ requiring
an additional call to <code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code> in order to really
free the string. Note that the automatic freeing of the string obtained
enabling modules automatic memory management counts for one
<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code> call (it is just executed automatically).
调用过该函数后，需要额外调用一次<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code> 真正释放字符串。注意，开启自动内存释放后，
每调用一次<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>，会增加一次计数。
Normally you want to call this function when, at the same time
the following conditions are true:
正常情况下，如下情况下，你会调用该函数</p>

<p>1) You have automatic memory management enabled.
1) 打开了自动内存管理
2) You want to create string objects.
2) 创建新的字符串对象
3) Those string objects you create need to live <em>after</em> the callback
   function(for example a command implementation) creating them returns.
3) 有些字符串对象，需要保存到回调函数执行完之后。
Usually you want this in order to store the created string object
into your own data structure, for example when implementing a new data
type.
通常情况，调用该函数是为了在自己创建的结构体里保存字符串对象，例如实现一种新的数据类型。</p>

<p>Note that when memory management is turned off, you don’t need
any call to RetainString() since creating a string will always result
into a string that lives after the callback function returns, if
no FreeString() call is performed.
注意，如果内存管理未启用，不需要调用RetainString()，已创建的字符串在调用FreeString()前会一存在。</p>
<h2 id="redismodule_stringptrlen"><code class="language-plaintext highlighter-rouge">RedisModule_StringPtrLen</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const char *RedisModule_StringPtrLen(const RedisModuleString *str, size_t *len);
</code></pre></div></div>

<p>Given a string module object, this function returns the string pointer
and length of the string. The returned pointer and length should only
be used for read only accesses and never modified.
返回给定字符串对象的指针和长度。注意，返回的字符串仅可读，不可修改。</p>
<h2 id="redismodule_stringtolonglong"><code class="language-plaintext highlighter-rouge">RedisModule_StringToLongLong</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_StringToLongLong(const RedisModuleString *str, long long *ll);
</code></pre></div></div>

<p>Convert the string into a long long integer, storing it at <code class="language-plaintext highlighter-rouge">*ll</code>.
Returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> on success. If the string can’t be parsed
as a valid, strict long long (no spaces before/after), <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code>
is returned.
将字符串转换为长整型，存储在<code class="language-plaintext highlighter-rouge">*ll</code>中，如果成功返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>，失败则返回<code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code>。</p>
<h2 id="redismodule_stringtodouble"><code class="language-plaintext highlighter-rouge">RedisModule_StringToDouble</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_StringToDouble(const RedisModuleString *str, double *d);
</code></pre></div></div>

<p>Convert the string into a double, storing it at <code class="language-plaintext highlighter-rouge">*d</code>.
Returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> on success or <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> if the string is
not a valid string representation of a double value.
将字符串转换为双精度类型，存储在<code class="language-plaintext highlighter-rouge">*d</code>中，如果成功返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>，失败则返回<code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code>。</p>
<h2 id="redismodule_stringcompare"><code class="language-plaintext highlighter-rouge">RedisModule_StringCompare</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_StringCompare(RedisModuleString *a, RedisModuleString *b);
</code></pre></div></div>

<p>Compare two string objects, returning -1, 0 or 1 respectively if
a &lt; b, a == b, a &gt; b. Strings are compared byte by byte as two
binary blobs without any encoding care / collation attempt.
比较两个字符串对象的大小，针对情况a &lt; b, a == b, a &gt; b 分别反馈-1,0,1。字符串按字节比较，不考虑编码和校验。</p>
<h2 id="redismodule_stringappendbuffer"><code class="language-plaintext highlighter-rouge">RedisModule_StringAppendBuffer</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len);
</code></pre></div></div>

<p>Append the specified buffere to the string ‘str’. The string must be a
string created by the user that is referenced only a single time, otherwise
<code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returend and the operation is not performed.
增加字符串<code class="language-plaintext highlighter-rouge">str</code>的内存，该字符串必须是用户创建和使用的，否则不做操作并返回<code class="language-plaintext highlighter-rouge">REDISMODULE_ERROR</code>。</p>

<h2 id="redismodule_wrongarity"><code class="language-plaintext highlighter-rouge">RedisModule_WrongArity</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_WrongArity(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Send an error about the number of arguments given to the command,
citing the command name in the error message.
发送参数个数不匹配的错误信息，错误信息包含该命令名称。
Example:
例子</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (argc != 3) return RedisModule_WrongArity(ctx);
</code></pre></div></div>

<h2 id="redismodule_replywithlonglong"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithLongLong</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll);
</code></pre></div></div>

<p>Send an integer reply to the client, with the specified long long value.
The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
向客户端返回长整型值。</p>
<h2 id="redismodule_replywitherror"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithError</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithError(RedisModuleCtx *ctx, const char *err);
</code></pre></div></div>

<p>Reply with the error ‘err’.
返回错误<code class="language-plaintext highlighter-rouge">err</code>
Note that ‘err’ must contain all the error, including
the initial error code. The function only provides the initial “-“, so
the usage is, for example:
注意，<code class="language-plaintext highlighter-rouge">err</code>必须包含所有报错，包括开头的错误代码，因此使用方法如下例
    RedisModule_ReplyWithError(ctx,”ERR Wrong Type”);</p>

<p>and not just:
而不是，这样：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModule_ReplyWithError(ctx,"Wrong Type");
</code></pre></div></div>

<p>The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
该函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>
<h2 id="redismodule_replywithsimplestring"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithSimpleString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg);
</code></pre></div></div>

<p>Reply with a simple string (+… \r\n in RESP protocol). This replies
are suitable only when sending a small non-binary string with small
overhead, like “OK” or similar replies.
回复简单字符串(+… \r\n)。对于仅返回非二进制简单字符串如”OK”比较合适。
The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
该函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>
<h2 id="redismodule_replywitharray"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithArray</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithArray(RedisModuleCtx *ctx, long len);
</code></pre></div></div>

<p>Reply with an array type of ‘len’ elements. However ‘len’ other calls
to <code class="language-plaintext highlighter-rouge">ReplyWith*</code> style functions must follow in order to emit the elements
of the array.
回复包含<code class="language-plaintext highlighter-rouge">len</code>个元素的数组。但是和<code class="language-plaintext highlighter-rouge">len</code>有关的其他<code class="language-plaintext highlighter-rouge">ReplyWith*</code>类型函数会被调用，用于取出和使用数组中的元素
When producing arrays with a number of element that is not known beforehand
the function can be called with the special count
<code class="language-plaintext highlighter-rouge">REDISMODULE_POSTPONED_ARRAY_LEN</code>, and the actual number of elements can be
later set with <code class="language-plaintext highlighter-rouge">RedisModule_ReplySetArrayLength()</code> (which will set the
latest “open” count if there are multiple ones).
当生成包含多个元素的数组是，可能预先不知道元素的个数，可以先使用<code class="language-plaintext highlighter-rouge">REDISMODULE_POSTPONED_ARRAY_LEN</code>进行设置。
实际的个数值可以通过后续调用<code class="language-plaintext highlighter-rouge">RedisModule_ReplySetArrayLength()</code>进行设置。</p>

<p>The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>
<h2 id="redismodule_replysetarraylength"><code class="language-plaintext highlighter-rouge">RedisModule_ReplySetArrayLength</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_ReplySetArrayLength(RedisModuleCtx *ctx, long len);
</code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithArray()</code> is used with the argument
<code class="language-plaintext highlighter-rouge">REDISMODULE_POSTPONED_ARRAY_LEN</code>, because we don’t know beforehand the number
of items we are going to output as elements of the array, this function
will take care to set the array length.
当<code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithArray()</code>使用了参数<code class="language-plaintext highlighter-rouge">REDISMODULE_POSTPONED_ARRAY_LEN</code>，设置数组长度值时需要注意。
因为很有可能有多个数组都没有设置元素个数。该函数只设置最新生成的数组的长度。</p>

<p>Since it is possible to have multiple array replies pending with unknown
length, this function guarantees to always set the latest array length
that was created in a postponed way.</p>

<p>For example in order to output an array like [1,[10,20,30]] we
could write:
例如，要输出数组[1,[10,20,30]],我们可以这样写</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);
 RedisModule_ReplyWithLongLong(ctx,1);
 RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);
 RedisModule_ReplyWithLongLong(ctx,10);
 RedisModule_ReplyWithLongLong(ctx,20);
 RedisModule_ReplyWithLongLong(ctx,30);
 RedisModule_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.
 RedisModule_ReplySetArrayLength(ctx,2); // Set len of top array
</code></pre></div></div>

<p>Note that in the above example there is no reason to postpone the array
length, since we produce a fixed number of elements, but in the practice
the code may use an interator or other ways of creating the output so
that is not easy to calculate in advance the number of elements.
注意，上例中，我们没必要延迟设置数组长度，因为生成的是一个固定个数的数组，但是实际生产中，
程序会使用迭代器或其他方法创建输出，因此很难算出数组中的元素个数。</p>
<h2 id="redismodule_replywithstringbuffer"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithStringBuffer</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len);
</code></pre></div></div>

<p>Reply with a bulk string, taking in input a C buffer pointer and length.</p>

<p>The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
批量返回字符串，每个字符串包含指向缓存的指针和字符串长度。
该函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>

<h2 id="redismodule_replywithstring"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);
</code></pre></div></div>

<p>Reply with a bulk string, taking in input a RedisModuleString object.</p>

<p>The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
批量返回字符串，每个字符串包含指向缓存的指针和字符串长度。
该函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>
<h2 id="redismodule_replywithnull"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithNull</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithNull(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Reply to the client with a NULL. In the RESP protocol a NULL is encoded
as the string “$-1\r\n”.</p>

<p>The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
恢复客户端NULL，在RESP协议中，NULL的编码为字符串变量“$-l\r\n”
该函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>
<h2 id="redismodule_replywithcallreply"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithCallReply</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply);
</code></pre></div></div>

<p>Reply exactly what a Redis command returned us with <code class="language-plaintext highlighter-rouge">RedisModule_Call()</code>.
This function is useful when we use <code class="language-plaintext highlighter-rouge">RedisModule_Call()</code> in order to
execute some command, as we want to reply to the client exactly the
same reply we obtained by the command.
将<code class="language-plaintext highlighter-rouge">RedisModule_Call()</code>的执行结果返回给客户端。当我们调用<code class="language-plaintext highlighter-rouge">RedisModule_Call()</code>执行命令，并希望
将我们收到的回复内容也返回给客户端时可以使用该函数。
The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
该函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.</p>
<h2 id="redismodule_replywithdouble"><code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithDouble</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplyWithDouble(RedisModuleCtx *ctx, double d);
</code></pre></div></div>

<p>Send a string reply obtained converting the double ‘d’ into a bulk string.
This function is basically equivalent to converting a double into
a string into a C buffer, and then calling the function
<code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithStringBuffer()</code> with the buffer and length.
该函数将double类型变量的返回结果<code class="language-plaintext highlighter-rouge">d</code>转换为字符串类型，然后调用函数<code class="language-plaintext highlighter-rouge">RedisModule_ReplyWithStringBuffer</code>
将结果返回给客户端。
The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.
该函数返回<code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code></p>
<h2 id="redismodule_replicate"><code class="language-plaintext highlighter-rouge">RedisModule_Replicate</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);
</code></pre></div></div>

<p>Replicate the specified command and arguments to slaves and AOF, as effect
of execution of the calling command implementation.
向从节点复制和AOF写入特定的命令和参数。
The replicated commands are always wrapped into the MULTI/EXEC that
contains all the commands replicated in a given module command
execution. However the commands replicated with <code class="language-plaintext highlighter-rouge">RedisModule_Call()</code>
are the first items, the ones replicated with <code class="language-plaintext highlighter-rouge">RedisModule_Replicate()</code>
will all follow before the EXEC.
被复制的命令通常都被MULTI/EXECT包裹在一个事务内，其中<code class="language-plaintext highlighter-rouge">RedisModule_Call()</code>复制的命令在第一位，<code class="language-plaintext highlighter-rouge">RedisModule_Replicate()</code>
复制的命令排在后面位置，但是在EXEC之前。</p>

<p>Modules should try to use one interface or the other.
模块建议使用同一个接口
This command follows exactly the same interface of <code class="language-plaintext highlighter-rouge">RedisModule_Call()</code>,
so a set of format specifiers must be passed, followed by arguments
matching the provided format specifiers.
该命令
Please refer to <code class="language-plaintext highlighter-rouge">RedisModule_Call()</code> for more information.</p>

<p>The command returns <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> if the format specifiers are invalid
or the command name does not belong to a known command.</p>

<h2 id="redismodule_replicateverbatim"><code class="language-plaintext highlighter-rouge">RedisModule_ReplicateVerbatim</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ReplicateVerbatim(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>This function will replicate the command exactly as it was invoked
by the client. Note that this function will not wrap the command into
a MULTI/EXEC stanza, so it should not be mixed with other replication
commands.</p>

<p>Basically this form of replication is useful when you want to propagate
the command to the slaves and AOF file exactly as it was called, since
the command can just be re-executed to deterministically re-create the
new state starting from the old one.</p>

<p>The function always returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>.</p>

<h2 id="redismodule_getclientid"><code class="language-plaintext highlighter-rouge">RedisModule_GetClientId</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned long long RedisModule_GetClientId(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Return the ID of the current client calling the currently active module
command. The returned ID has a few guarantees:</p>

<ol>
  <li>The ID is different for each different client, so if the same client
executes a module command multiple times, it can be recognized as
having the same ID, otherwise the ID will be different.</li>
  <li>The ID increases monotonically. Clients connecting to the server later
are guaranteed to get IDs greater than any past ID previously seen.</li>
</ol>

<p>Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way
to fetch the ID in the context the function was currently called.</p>

<h2 id="redismodule_getselecteddb"><code class="language-plaintext highlighter-rouge">RedisModule_GetSelectedDb</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_GetSelectedDb(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Return the currently selected DB.</p>

<h2 id="redismodule_selectdb"><code class="language-plaintext highlighter-rouge">RedisModule_SelectDb</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_SelectDb(RedisModuleCtx *ctx, int newid);
</code></pre></div></div>

<p>Change the currently selected DB. Returns an error if the id
is out of range.</p>

<p>Note that the client will retain the currently selected DB even after
the Redis command implemented by the module calling this function
returns.</p>

<p>If the module command wishes to change something in a different DB and
returns back to the original one, it should call <code class="language-plaintext highlighter-rouge">RedisModule_GetSelectedDb()</code>
before in order to restore the old DB number before returning.</p>

<h2 id="redismodule_openkey"><code class="language-plaintext highlighter-rouge">RedisModule_OpenKey</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *RedisModule_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode);
</code></pre></div></div>

<p>Return an handle representing a Redis key, so that it is possible
to call other APIs with the key handle as argument to perform
operations on the key.</p>

<p>The return value is the handle repesenting the key, that must be
closed with <code class="language-plaintext highlighter-rouge">RM_CloseKey()</code>.</p>

<p>If the key does not exist and WRITE mode is requested, the handle
is still returned, since it is possible to perform operations on
a yet not existing key (that will be created, for example, after
a list push operation). If the mode is just READ instead, and the
key does not exist, NULL is returned. However it is still safe to
call <code class="language-plaintext highlighter-rouge">RedisModule_CloseKey()</code> and <code class="language-plaintext highlighter-rouge">RedisModule_KeyType()</code> on a NULL
value.</p>

<h2 id="redismodule_closekey"><code class="language-plaintext highlighter-rouge">RedisModule_CloseKey</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_CloseKey(RedisModuleKey *key);
</code></pre></div></div>

<p>Close a key handle.</p>

<h2 id="redismodule_keytype"><code class="language-plaintext highlighter-rouge">RedisModule_KeyType</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_KeyType(RedisModuleKey *key);
</code></pre></div></div>

<p>Return the type of the key. If the key pointer is NULL then
<code class="language-plaintext highlighter-rouge">REDISMODULE_KEYTYPE_EMPTY</code> is returned.</p>

<h2 id="redismodule_valuelength"><code class="language-plaintext highlighter-rouge">RedisModule_ValueLength</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>size_t RedisModule_ValueLength(RedisModuleKey *key);
</code></pre></div></div>

<p>Return the length of the value associated with the key.
For strings this is the length of the string. For all the other types
is the number of elements (just counting keys for hashes).</p>

<p>If the key pointer is NULL or the key is empty, zero is returned.</p>

<h2 id="redismodule_deletekey"><code class="language-plaintext highlighter-rouge">RedisModule_DeleteKey</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_DeleteKey(RedisModuleKey *key);
</code></pre></div></div>

<p>If the key is open for writing, remove it, and setup the key to
accept new writes as an empty key (that will be created on demand).
On success <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> is returned. If the key is not open for
writing <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned.</p>

<h2 id="redismodule_getexpire"><code class="language-plaintext highlighter-rouge">RedisModule_GetExpire</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mstime_t RedisModule_GetExpire(RedisModuleKey *key);
</code></pre></div></div>

<p>Return the key expire value, as milliseconds of remaining TTL.
If no TTL is associated with the key or if the key is empty,
<code class="language-plaintext highlighter-rouge">REDISMODULE_NO_EXPIRE</code> is returned.</p>

<h2 id="redismodule_setexpire"><code class="language-plaintext highlighter-rouge">RedisModule_SetExpire</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_SetExpire(RedisModuleKey *key, mstime_t expire);
</code></pre></div></div>

<p>Set a new expire for the key. If the special expire
<code class="language-plaintext highlighter-rouge">REDISMODULE_NO_EXPIRE</code> is set, the expire is cancelled if there was
one (the same as the PERSIST command).</p>

<p>Note that the expire must be provided as a positive integer representing
the number of milliseconds of TTL the key should have.</p>

<p>The function returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> on success or <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> if
the key was not open for writing or is an empty key.</p>

<h2 id="redismodule_stringset"><code class="language-plaintext highlighter-rouge">RedisModule_StringSet</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_StringSet(RedisModuleKey *key, RedisModuleString *str);
</code></pre></div></div>

<p>If the key is open for writing, set the specified string ‘str’ as the
value of the key, deleting the old value if any.
On success <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> is returned. If the key is not open for
writing or there is an active iterator, <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned.</p>

<h2 id="redismodule_stringdma"><code class="language-plaintext highlighter-rouge">RedisModule_StringDMA</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char *RedisModule_StringDMA(RedisModuleKey *key, size_t *len, int mode);
</code></pre></div></div>

<p>Prepare the key associated string value for DMA access, and returns
a pointer and size (by reference), that the user can use to read or
modify the string in-place accessing it directly via pointer.</p>

<p>The ‘mode’ is composed by bitwise OR-ing the following flags:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REDISMODULE_READ -- Read access
REDISMODULE_WRITE -- Write access
</code></pre></div></div>

<p>If the DMA is not requested for writing, the pointer returned should
only be accessed in a read-only fashion.</p>

<p>On error (wrong type) NULL is returned.</p>

<p>DMA access rules:</p>

<ol>
  <li>
    <p>No other key writing function should be called since the moment
the pointer is obtained, for all the time we want to use DMA access
to read or modify the string.</p>
  </li>
  <li>
    <p>Each time <code class="language-plaintext highlighter-rouge">RM_StringTruncate()</code> is called, to continue with the DMA
access, <code class="language-plaintext highlighter-rouge">RM_StringDMA()</code> should be called again to re-obtain
a new pointer and length.</p>
  </li>
  <li>
    <p>If the returned pointer is not NULL, but the length is zero, no
byte can be touched (the string is empty, or the key itself is empty)
so a <code class="language-plaintext highlighter-rouge">RM_StringTruncate()</code> call should be used if there is to enlarge
the string, and later call StringDMA() again to get the pointer.</p>
  </li>
</ol>

<h2 id="redismodule_stringtruncate"><code class="language-plaintext highlighter-rouge">RedisModule_StringTruncate</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_StringTruncate(RedisModuleKey *key, size_t newlen);
</code></pre></div></div>

<p>If the string is open for writing and is of string type, resize it, padding
with zero bytes if the new length is greater than the old one.</p>

<p>After this call, <code class="language-plaintext highlighter-rouge">RM_StringDMA()</code> must be called again to continue
DMA access with the new pointer.</p>

<p>The function returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> on success, and <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> on
error, that is, the key is not open for writing, is not a string
or resizing for more than 512 MB is requested.</p>

<p>If the key is empty, a string key is created with the new string value
unless the new length value requested is zero.</p>

<h2 id="redismodule_listpush"><code class="language-plaintext highlighter-rouge">RedisModule_ListPush</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele);
</code></pre></div></div>

<p>Push an element into a list, on head or tail depending on ‘where’ argumnet.
If the key pointer is about an empty key opened for writing, the key
is created. On error (key opened for read-only operations or of the wrong
type) <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned, otherwise <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> is returned.</p>

<h2 id="redismodule_listpop"><code class="language-plaintext highlighter-rouge">RedisModule_ListPop</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_ListPop(RedisModuleKey *key, int where);
</code></pre></div></div>

<p>Pop an element from the list, and returns it as a module string object
that the user should be free with <code class="language-plaintext highlighter-rouge">RM_FreeString()</code> or by enabling
automatic memory. ‘where’ specifies if the element should be popped from
head or tail. The command returns NULL if:
1) The list is empty.
2) The key was not open for writing.
3) The key is not a list.</p>

<h2 id="redismodule_zsetaddflagstocoreflags"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetAddFlagsToCoreFlags</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetAddFlagsToCoreFlags(int flags);
</code></pre></div></div>

<p>Conversion from/to public flags of the Modules API and our private flags,
so that we have everything decoupled.</p>

<h2 id="redismodule_zsetaddflagsfromcoreflags"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetAddFlagsFromCoreFlags</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetAddFlagsFromCoreFlags(int flags);
</code></pre></div></div>

<p>See previous function comment.</p>

<h2 id="redismodule_zsetadd"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetAdd</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr);
</code></pre></div></div>

<p>Add a new element into a sorted set, with the specified ‘score’.
If the element already exists, the score is updated.</p>

<p>A new sorted set is created at value if the key is an empty open key
setup for writing.</p>

<p>Additional flags can be passed to the function via a pointer, the flags
are both used to receive input and to communicate state when the function
returns. ‘flagsptr’ can be NULL if no special flags are used.</p>

<p>The input flags are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REDISMODULE_ZADD_XX: Element must already exist. Do nothing otherwise.
REDISMODULE_ZADD_NX: Element must not exist. Do nothing otherwise.
</code></pre></div></div>

<p>The output flags are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REDISMODULE_ZADD_ADDED: The new element was added to the sorted set.
REDISMODULE_ZADD_UPDATED: The score of the element was updated.
REDISMODULE_ZADD_NOP: No operation was performed because XX or NX flags.
</code></pre></div></div>

<p>On success the function returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>. On the following errors
<code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned:</p>

<ul>
  <li>The key was not opened for writing.</li>
  <li>The key is of the wrong type.</li>
  <li>‘score’ double value is not a number (NaN).</li>
</ul>

<h2 id="redismodule_zsetincrby"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetIncrby</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore);
</code></pre></div></div>

<p>This function works exactly like <code class="language-plaintext highlighter-rouge">RM_ZsetAdd()</code>, but instead of setting
a new score, the score of the existing element is incremented, or if the
element does not already exist, it is added assuming the old score was
zero.</p>

<p>The input and output flags, and the return value, have the same exact
meaning, with the only difference that this function will return
<code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> even when ‘score’ is a valid double number, but adding it
to the existing score resuts into a NaN (not a number) condition.</p>

<p>This function has an additional field ‘newscore’, if not NULL is filled
with the new score of the element after the increment, if no error
is returned.</p>

<h2 id="redismodule_zsetrem"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetRem</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted);
</code></pre></div></div>

<p>Remove the specified element from the sorted set.
The function returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> on success, and <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code>
on one of the following conditions:</p>

<ul>
  <li>The key was not opened for writing.</li>
  <li>The key is of the wrong type.</li>
</ul>

<p>The return value does NOT indicate the fact the element was really
removed (since it existed) or not, just if the function was executed
with success.</p>

<p>In order to know if the element was removed, the additional argument
‘deleted’ must be passed, that populates the integer by reference
setting it to 1 or 0 depending on the outcome of the operation.
The ‘deleted’ argument can be NULL if the caller is not interested
to know if the element was really removed.</p>

<p>Empty keys will be handled correctly by doing nothing.</p>

<h2 id="redismodule_zsetscore"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetScore</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score);
</code></pre></div></div>

<p>On success retrieve the double score associated at the sorted set element
‘ele’ and returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code>. Otherwise <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned
to signal one of the following conditions:</p>

<ul>
  <li>There is no such element ‘ele’ in the sorted set.</li>
  <li>The key is not a sorted set.</li>
  <li>The key is an open empty key.</li>
</ul>

<h2 id="redismodule_zsetrangestop"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetRangeStop</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_ZsetRangeStop(RedisModuleKey *key);
</code></pre></div></div>

<p>Stop a sorted set iteration.</p>

<h2 id="redismodule_zsetrangeendreached"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetRangeEndReached</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetRangeEndReached(RedisModuleKey *key);
</code></pre></div></div>

<p>Return the “End of range” flag value to signal the end of the iteration.</p>

<h2 id="redismodule_zsetfirstinscorerange"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetFirstInScoreRange</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);
</code></pre></div></div>

<p>Setup a sorted set iterator seeking the first element in the specified
range. Returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> if the iterator was correctly initialized
otherwise <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned in the following conditions:</p>

<ol>
  <li>The value stored at key is not a sorted set or the key is empty.</li>
</ol>

<p>The range is specified according to the two double values ‘min’ and ‘max’.
Both can be infinite using the following two macros:</p>

<p><code class="language-plaintext highlighter-rouge">REDISMODULE_POSITIVE_INFINITE</code> for positive infinite value
<code class="language-plaintext highlighter-rouge">REDISMODULE_NEGATIVE_INFINITE</code> for negative infinite value</p>

<p>‘minex’ and ‘maxex’ parameters, if true, respectively setup a range
where the min and max value are exclusive (not included) instead of
inclusive.</p>

<h2 id="redismodule_zsetlastinscorerange"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetLastInScoreRange</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);
</code></pre></div></div>

<p>Exactly like <code class="language-plaintext highlighter-rouge">RedisModule_ZsetFirstInScoreRange()</code> but the last element of
the range is selected for the start of the iteration instead.</p>

<h2 id="redismodule_zsetfirstinlexrange"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetFirstInLexRange</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);
</code></pre></div></div>

<p>Setup a sorted set iterator seeking the first element in the specified
lexicographical range. Returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> if the iterator was correctly
initialized otherwise <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned in the
following conditions:</p>

<ol>
  <li>The value stored at key is not a sorted set or the key is empty.</li>
  <li>The lexicographical range ‘min’ and ‘max’ format is invalid.</li>
</ol>

<p>‘min’ and ‘max’ should be provided as two RedisModuleString objects
in the same format as the parameters passed to the ZRANGEBYLEX command.
The function does not take ownership of the objects, so they can be released
ASAP after the iterator is setup.</p>

<h2 id="redismodule_zsetlastinlexrange"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetLastInLexRange</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);
</code></pre></div></div>

<p>Exactly like <code class="language-plaintext highlighter-rouge">RedisModule_ZsetFirstInLexRange()</code> but the last element of
the range is selected for the start of the iteration instead.</p>

<h2 id="redismodule_zsetrangecurrentelement"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetRangeCurrentElement</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_ZsetRangeCurrentElement(RedisModuleKey *key, double *score);
</code></pre></div></div>

<p>Return the current sorted set element of an active sorted set iterator
or NULL if the range specified in the iterator does not include any
element.</p>

<h2 id="redismodule_zsetrangenext"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetRangeNext</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetRangeNext(RedisModuleKey *key);
</code></pre></div></div>

<p>Go to the next element of the sorted set iterator. Returns 1 if there was
a next element, 0 if we are already at the latest element or the range
does not include any item at all.</p>

<h2 id="redismodule_zsetrangeprev"><code class="language-plaintext highlighter-rouge">RedisModule_ZsetRangePrev</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ZsetRangePrev(RedisModuleKey *key);
</code></pre></div></div>

<p>Go to the previous element of the sorted set iterator. Returns 1 if there was
a previous element, 0 if we are already at the first element or the range
does not include any item at all.</p>

<h2 id="redismodule_hashset"><code class="language-plaintext highlighter-rouge">RedisModule_HashSet</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_HashSet(RedisModuleKey *key, int flags, ...);
</code></pre></div></div>

<p>Set the field of the specified hash field to the specified value.
If the key is an empty key open for writing, it is created with an empty
hash value, in order to set the specified field.</p>

<p>The function is variadic and the user must specify pairs of field
names and values, both as RedisModuleString pointers (unless the
CFIELD option is set, see later).</p>

<p>Example to set the hash argv[1] to the value argv[2]:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);
</code></pre></div></div>

<p>The function can also be used in order to delete fields (if they exist)
by setting them to the specified value of <code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_DELETE</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],
                     REDISMODULE_HASH_DELETE,NULL);
</code></pre></div></div>

<p>The behavior of the command changes with the specified flags, that can be
set to <code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_NONE</code> if no special behavior is needed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REDISMODULE_HASH_NX: The operation is performed only if the field was not
                     already existing in the hash.
REDISMODULE_HASH_XX: The operation is performed only if the field was
                     already existing, so that a new value could be
                     associated to an existing filed, but no new fields
                     are created.
REDISMODULE_HASH_CFIELDS: The field names passed are null terminated C
                          strings instead of RedisModuleString objects.
</code></pre></div></div>

<p>Unless NX is specified, the command overwrites the old field value with
the new one.</p>

<p>When using <code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_CFIELDS</code>, field names are reported using
normal C strings, so for example to delete the field “foo” the following
code can be used:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,"foo",
                     REDISMODULE_HASH_DELETE,NULL);
</code></pre></div></div>

<p>Return value:</p>

<p>The number of fields updated (that may be less than the number of fields
specified because of the XX or NX options).</p>

<p>In the following case the return value is always zero:</p>

<ul>
  <li>The key was not open for writing.</li>
  <li>The key was associated with a non Hash value.</li>
</ul>

<h2 id="redismodule_hashget"><code class="language-plaintext highlighter-rouge">RedisModule_HashGet</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_HashGet(RedisModuleKey *key, int flags, ...);
</code></pre></div></div>

<p>Get fields from an hash value. This function is called using a variable
number of arguments, alternating a field name (as a StringRedisModule
pointer) with a pointer to a StringRedisModule pointer, that is set to the
value of the field if the field exist, or NULL if the field did not exist.
At the end of the field/value-ptr pairs, NULL must be specified as last
argument to signal the end of the arguments in the variadic function.</p>

<p>This is an example usage:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RedisModuleString *first, *second;
 RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&amp;first,
                 argv[2],&amp;second,NULL);
</code></pre></div></div>

<p>As with <code class="language-plaintext highlighter-rouge">RedisModule_HashSet()</code> the behavior of the command can be specified
passing flags different than <code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_NONE</code>:</p>

<p><code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_CFIELD</code>: field names as null terminated C strings.</p>

<p><code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_EXISTS</code>: instead of setting the value of the field
expecting a RedisModuleString pointer to pointer, the function just
reports if the field esists or not and expects an integer pointer
as the second element of each pair.</p>

<p>Example of <code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_CFIELD</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RedisModuleString *username, *hashedpass;
 RedisModule_HashGet(mykey,"username",&amp;username,"hp",&amp;hashedpass, NULL);
</code></pre></div></div>

<p>Example of <code class="language-plaintext highlighter-rouge">REDISMODULE_HASH_EXISTS</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> int exists;
 RedisModule_HashGet(mykey,argv[1],&amp;exists,NULL);
</code></pre></div></div>

<p>The function returns <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> on success and <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> if
the key is not an hash value.</p>

<p>Memory management:</p>

<p>The returned RedisModuleString objects should be released with
<code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>, or by enabling automatic memory management.</p>

<h2 id="redismodule_freecallreply_rec"><code class="language-plaintext highlighter-rouge">RedisModule_FreeCallReply_Rec</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested);
</code></pre></div></div>

<p>Free a Call reply and all the nested replies it contains if it’s an
array.</p>

<h2 id="redismodule_freecallreply"><code class="language-plaintext highlighter-rouge">RedisModule_FreeCallReply</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_FreeCallReply(RedisModuleCallReply *reply);
</code></pre></div></div>

<p>Wrapper for the recursive free reply function. This is needed in order
to have the first level function to return on nested replies, but only
if called by the module API.</p>

<h2 id="redismodule_callreplytype"><code class="language-plaintext highlighter-rouge">RedisModule_CallReplyType</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_CallReplyType(RedisModuleCallReply *reply);
</code></pre></div></div>

<p>Return the reply type.</p>

<h2 id="redismodule_callreplylength"><code class="language-plaintext highlighter-rouge">RedisModule_CallReplyLength</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>size_t RedisModule_CallReplyLength(RedisModuleCallReply *reply);
</code></pre></div></div>

<p>Return the reply type length, where applicable.</p>

<h2 id="redismodule_callreplyarrayelement"><code class="language-plaintext highlighter-rouge">RedisModule_CallReplyArrayElement</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleCallReply *RedisModule_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx);
</code></pre></div></div>

<p>Return the ‘idx’-th nested call reply element of an array reply, or NULL
if the reply type is wrong or the index is out of range.</p>

<h2 id="redismodule_callreplyinteger"><code class="language-plaintext highlighter-rouge">RedisModule_CallReplyInteger</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>long long RedisModule_CallReplyInteger(RedisModuleCallReply *reply);
</code></pre></div></div>

<p>Return the long long of an integer reply.</p>

<h2 id="redismodule_callreplystringptr"><code class="language-plaintext highlighter-rouge">RedisModule_CallReplyStringPtr</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const char *RedisModule_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len);
</code></pre></div></div>

<p>Return the pointer and length of a string or error reply.</p>

<h2 id="redismodule_createstringfromcallreply"><code class="language-plaintext highlighter-rouge">RedisModule_CreateStringFromCallReply</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_CreateStringFromCallReply(RedisModuleCallReply *reply);
</code></pre></div></div>

<p>Return a new string object from a call reply of type string, error or
integer. Otherwise (wrong reply type) return NULL.</p>

<h2 id="redismodule_call"><code class="language-plaintext highlighter-rouge">RedisModule_Call</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleCallReply *RedisModule_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);
</code></pre></div></div>

<p>Exported API to call any Redis command from modules.
On success a RedisModuleCallReply object is returned, otherwise
NULL is returned and errno is set to the following values:</p>

<p>EINVAL: command non existing, wrong arity, wrong format specifier.
EPERM:  operation in Cluster instance with key in non local slot.</p>

<h2 id="redismodule_callreplyproto"><code class="language-plaintext highlighter-rouge">RedisModule_CallReplyProto</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const char *RedisModule_CallReplyProto(RedisModuleCallReply *reply, size_t *len);
</code></pre></div></div>

<p>Return a pointer, and a length, to the protocol returned by the command
that returned the reply object.</p>

<h2 id="redismodule_createdatatype"><code class="language-plaintext highlighter-rouge">RedisModule_CreateDataType</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moduleType *RedisModule_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr);
</code></pre></div></div>

<p>Register a new data type exported by the module. The parameters are the
following. Please for in depth documentation check the modules API
documentation, especially the TYPES.md file.</p>

<ul>
  <li><strong>name</strong>: A 9 characters data type name that MUST be unique in the Redis
Modules ecosystem. Be creative… and there will be no collisions. Use
the charset A-Z a-z 9-0, plus the two “-_” characters. A good
idea is to use, for example <code class="language-plaintext highlighter-rouge">&lt;typename&gt;-&lt;vendor&gt;</code>. For example
“tree-AntZ” may mean “Tree data structure by @antirez”. To use both
lower case and upper case letters helps in order to prevent collisions.</li>
  <li><strong>encver</strong>: Encoding version, which is, the version of the serialization
that a module used in order to persist data. As long as the “name”
matches, the RDB loading will be dispatched to the type callbacks
whatever ‘encver’ is used, however the module can understand if
the encoding it must load are of an older version of the module.
For example the module “tree-AntZ” initially used encver=0. Later
after an upgrade, it started to serialize data in a different format
and to register the type with encver=1. However this module may
still load old data produced by an older version if the rdb_load
callback is able to check the encver value and act accordingly.
The encver must be a positive value between 0 and 1023.</li>
  <li>
    <p><strong>typemethods_ptr</strong> is a pointer to a RedisModuleTypeMethods structure
that should be populated with the methods callbacks and structure
version, like in the following example:</p>

    <p>RedisModuleTypeMethods tm = {
       .version = REDISMODULE_TYPE_METHOD_VERSION,
       .rdb_load = myType_RDBLoadCallBack,
       .rdb_save = myType_RDBSaveCallBack,
       .aof_rewrite = myType_AOFRewriteCallBack,
       .free = myType_FreeCallBack,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   // Optional fields
   .digest = myType_DigestCallBack,
   .mem_usage = myType_MemUsageCallBack,    }
</code></pre></div>    </div>
  </li>
  <li><strong>rdb_load</strong>: A callback function pointer that loads data from RDB files.</li>
  <li><strong>rdb_save</strong>: A callback function pointer that saves data to RDB files.</li>
  <li><strong>aof_rewrite</strong>: A callback function pointer that rewrites data as commands.</li>
  <li><strong>digest</strong>: A callback function pointer that is used for <code class="language-plaintext highlighter-rouge">DEBUG DIGEST</code>.</li>
  <li><strong>free</strong>: A callback function pointer that can free a type value.</li>
</ul>

<p>The <strong>digest* and **mem_usage</strong> methods should currently be omitted since
they are not yet implemented inside the Redis modules core.</p>

<p>Note: the module name “AAAAAAAAA” is reserved and produces an error, it
happens to be pretty lame as well.</p>

<p>If there is already a module registering a type with the same name,
and if the module name or encver is invalid, NULL is returned.
Otherwise the new type is registered into Redis, and a reference of
type RedisModuleType is returned: the caller of the function should store
this reference into a gobal variable to make future use of it in the
modules type API, since a single module may register multiple types.
Example code fragment:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> static RedisModuleType *BalancedTreeType;

 int RedisModule_OnLoad(RedisModuleCtx *ctx) {
     // some code here ...
     BalancedTreeType = RM_CreateDataType(...);
 }
</code></pre></div></div>

<h2 id="redismodule_moduletypesetvalue"><code class="language-plaintext highlighter-rouge">RedisModule_ModuleTypeSetValue</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value);
</code></pre></div></div>

<p>If the key is open for writing, set the specified module type object
as the value of the key, deleting the old value if any.
On success <code class="language-plaintext highlighter-rouge">REDISMODULE_OK</code> is returned. If the key is not open for
writing or there is an active iterator, <code class="language-plaintext highlighter-rouge">REDISMODULE_ERR</code> is returned.</p>

<h2 id="redismodule_moduletypegettype"><code class="language-plaintext highlighter-rouge">RedisModule_ModuleTypeGetType</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moduleType *RedisModule_ModuleTypeGetType(RedisModuleKey *key);
</code></pre></div></div>

<p>Assuming <code class="language-plaintext highlighter-rouge">RedisModule_KeyType()</code> returned <code class="language-plaintext highlighter-rouge">REDISMODULE_KEYTYPE_MODULE</code> on
the key, returns the moduel type pointer of the value stored at key.</p>

<p>If the key is NULL, is not associated with a module type, or is empty,
then NULL is returned instead.</p>

<h2 id="redismodule_moduletypegetvalue"><code class="language-plaintext highlighter-rouge">RedisModule_ModuleTypeGetValue</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *RedisModule_ModuleTypeGetValue(RedisModuleKey *key);
</code></pre></div></div>

<p>Assuming <code class="language-plaintext highlighter-rouge">RedisModule_KeyType()</code> returned <code class="language-plaintext highlighter-rouge">REDISMODULE_KEYTYPE_MODULE</code> on
the key, returns the module type low-level value stored at key, as
it was set by the user via <code class="language-plaintext highlighter-rouge">RedisModule_ModuleTypeSet()</code>.</p>

<p>If the key is NULL, is not associated with a module type, or is empty,
then NULL is returned instead.</p>

<h2 id="redismodule_saveunsigned"><code class="language-plaintext highlighter-rouge">RedisModule_SaveUnsigned</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_SaveUnsigned(RedisModuleIO *io, uint64_t value);
</code></pre></div></div>

<p>Save an unsigned 64 bit value into the RDB file. This function should only
be called in the context of the rdb_save method of modules implementing new
data types.</p>

<h2 id="redismodule_loadunsigned"><code class="language-plaintext highlighter-rouge">RedisModule_LoadUnsigned</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uint64_t RedisModule_LoadUnsigned(RedisModuleIO *io);
</code></pre></div></div>

<p>Load an unsigned 64 bit value from the RDB file. This function should only
be called in the context of the rdb_load method of modules implementing
new data types.</p>

<h2 id="redismodule_savesigned"><code class="language-plaintext highlighter-rouge">RedisModule_SaveSigned</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_SaveSigned(RedisModuleIO *io, int64_t value);
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">RedisModule_SaveUnsigned()</code> but for signed 64 bit values.</p>

<h2 id="redismodule_loadsigned"><code class="language-plaintext highlighter-rouge">RedisModule_LoadSigned</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int64_t RedisModule_LoadSigned(RedisModuleIO *io);
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">RedisModule_LoadUnsigned()</code> but for signed 64 bit values.</p>

<h2 id="redismodule_savestring"><code class="language-plaintext highlighter-rouge">RedisModule_SaveString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_SaveString(RedisModuleIO *io, RedisModuleString *s);
</code></pre></div></div>

<p>In the context of the rdb_save method of a module type, saves a
string into the RDB file taking as input a RedisModuleString.</p>

<p>The string can be later loaded with <code class="language-plaintext highlighter-rouge">RedisModule_LoadString()</code> or
other Load family functions expecting a serialized string inside
the RDB file.</p>

<h2 id="redismodule_savestringbuffer"><code class="language-plaintext highlighter-rouge">RedisModule_SaveStringBuffer</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">RedisModule_SaveString()</code> but takes a raw C pointer and length
as input.</p>

<h2 id="redismodule_loadstring"><code class="language-plaintext highlighter-rouge">RedisModule_LoadString</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleString *RedisModule_LoadString(RedisModuleIO *io);
</code></pre></div></div>

<p>In the context of the rdb_load method of a module data type, loads a string
from the RDB file, that was previously saved with <code class="language-plaintext highlighter-rouge">RedisModule_SaveString()</code>
functions family.</p>

<p>The returned string is a newly allocated RedisModuleString object, and
the user should at some point free it with a call to <code class="language-plaintext highlighter-rouge">RedisModule_FreeString()</code>.</p>

<p>If the data structure does not store strings as RedisModuleString objects,
the similar function <code class="language-plaintext highlighter-rouge">RedisModule_LoadStringBuffer()</code> could be used instead.</p>

<h2 id="redismodule_loadstringbuffer"><code class="language-plaintext highlighter-rouge">RedisModule_LoadStringBuffer</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char *RedisModule_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">RedisModule_LoadString()</code> but returns an heap allocated string that
was allocated with <code class="language-plaintext highlighter-rouge">RedisModule_Alloc()</code>, and can be resized or freed with
<code class="language-plaintext highlighter-rouge">RedisModule_Realloc()</code> or <code class="language-plaintext highlighter-rouge">RedisModule_Free()</code>.</p>

<p>The size of the string is stored at ‘*lenptr’ if not NULL.
The returned string is not automatically NULL termianted, it is loaded
exactly as it was stored inisde the RDB file.</p>

<h2 id="redismodule_savedouble"><code class="language-plaintext highlighter-rouge">RedisModule_SaveDouble</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_SaveDouble(RedisModuleIO *io, double value);
</code></pre></div></div>

<p>In the context of the rdb_save method of a module data type, saves a double
value to the RDB file. The double can be a valid number, a NaN or infinity.
It is possible to load back the value with <code class="language-plaintext highlighter-rouge">RedisModule_LoadDouble()</code>.</p>

<h2 id="redismodule_loaddouble"><code class="language-plaintext highlighter-rouge">RedisModule_LoadDouble</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>double RedisModule_LoadDouble(RedisModuleIO *io);
</code></pre></div></div>

<p>In the context of the rdb_save method of a module data type, loads back the
double value saved by <code class="language-plaintext highlighter-rouge">RedisModule_SaveDouble()</code>.</p>

<h2 id="redismodule_savefloat"><code class="language-plaintext highlighter-rouge">RedisModule_SaveFloat</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_SaveFloat(RedisModuleIO *io, float value);
</code></pre></div></div>

<p>In the context of the rdb_save method of a module data type, saves a float
value to the RDB file. The float can be a valid number, a NaN or infinity.
It is possible to load back the value with <code class="language-plaintext highlighter-rouge">RedisModule_LoadFloat()</code>.</p>

<h2 id="redismodule_loadfloat"><code class="language-plaintext highlighter-rouge">RedisModule_LoadFloat</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>float RedisModule_LoadFloat(RedisModuleIO *io);
</code></pre></div></div>

<p>In the context of the rdb_save method of a module data type, loads back the
float value saved by <code class="language-plaintext highlighter-rouge">RedisModule_SaveFloat()</code>.</p>

<h2 id="redismodule_digestaddstringbuffer"><code class="language-plaintext highlighter-rouge">RedisModule_DigestAddStringBuffer</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len);
</code></pre></div></div>

<p>Add a new element to the digest. This function can be called multiple times
one element after the other, for all the elements that constitute a given
data structure. The function call must be followed by the call to
<code class="language-plaintext highlighter-rouge">RedisModule_DigestEndSequence</code> eventually, when all the elements that are
always in a given order are added. See the Redis Modules data types
documentation for more info. However this is a quick example that uses Redis
data types as an example.</p>

<p>To add a sequence of unordered elements (for example in the case of a Redis
Set), the pattern to use is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foreach element {
    AddElement(element);
    EndSequence();
}
</code></pre></div></div>

<p>Because Sets are not ordered, so every element added has a position that
does not depend from the other. However if instead our elements are
ordered in pairs, like field-value pairs of an Hash, then one should
use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foreach key,value {
    AddElement(key);
    AddElement(value);
    EndSquence();
}
</code></pre></div></div>

<p>Because the key and value will be always in the above order, while instead
the single key-value pairs, can appear in any position into a Redis hash.</p>

<p>A list of ordered elements would be implemented with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foreach element {
    AddElement(element);
}
EndSequence();
</code></pre></div></div>

<h2 id="redismodule_digestaddlonglong"><code class="language-plaintext highlighter-rouge">RedisModule_DigestAddLongLong</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_DigestAddLongLong(RedisModuleDigest *md, long long ll);
</code></pre></div></div>

<p>Like <code class="language-plaintext highlighter-rouge">RedisModule_DigestAddStringBuffer()</code> but takes a long long as input
that gets converted into a string before adding it to the digest.</p>

<h2 id="redismodule_digestendsequence"><code class="language-plaintext highlighter-rouge">RedisModule_DigestEndSequence</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_DigestEndSequence(RedisModuleDigest *md);
</code></pre></div></div>

<p>See the doucmnetation for <code class="language-plaintext highlighter-rouge">RedisModule_DigestAddElement()</code>.</p>

<h2 id="redismodule_emitaof"><code class="language-plaintext highlighter-rouge">RedisModule_EmitAOF</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);
</code></pre></div></div>

<p>Emits a command into the AOF during the AOF rewriting process. This function
is only called in the context of the aof_rewrite method of data types exported
by a module. The command works exactly like <code class="language-plaintext highlighter-rouge">RedisModule_Call()</code> in the way
the parameters are passed, but it does not return anything as the error
handling is performed by Redis itself.</p>

<h2 id="redismodule_lograw"><code class="language-plaintext highlighter-rouge">RedisModule_LogRaw</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap);
</code></pre></div></div>

<p>This is the low level function implementing both:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RM_Log()
 RM_LogIOError()
</code></pre></div></div>

<h2 id="redismodule_log"><code class="language-plaintext highlighter-rouge">RedisModule_Log</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...);
</code></pre></div></div>

<p>Produces a log message to the standard Redis log, the format accepts
printf-alike specifiers, while level is a string describing the log
level to use when emitting the log, and must be one of the following:</p>

<ul>
  <li>“debug”</li>
  <li>“verbose”</li>
  <li>“notice”</li>
  <li>“warning”</li>
</ul>

<p>If the specified log level is invalid, verbose is used by default.
There is a fixed limit to the length of the log line this function is able
to emit, this limti is not specified but is guaranteed to be more than
a few lines of text.</p>

<h2 id="redismodule_logioerror"><code class="language-plaintext highlighter-rouge">RedisModule_LogIOError</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...);
</code></pre></div></div>

<p>Log errors from RDB / AOF serialization callbacks.</p>

<p>This function should be used when a callback is returning a critical
error to the caller since cannot load or save the data for some
critical reason.</p>

<h2 id="redismodule_blockclient"><code class="language-plaintext highlighter-rouge">RedisModule_BlockClient</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleBlockedClient *RedisModule_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(void*), long long timeout_ms);
</code></pre></div></div>

<p>Block a client in the context of a blocking command, returning an handle
which will be used, later, in order to block the client with a call to
<code class="language-plaintext highlighter-rouge">RedisModule_UnblockClient()</code>. The arguments specify callback functions
and a timeout after which the client is unblocked.</p>

<p>The callbacks are called in the following contexts:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reply_callback:  called after a successful RedisModule_UnblockClient()
                 call in order to reply to the client and unblock it.

reply_timeout:   called when the timeout is reached in order to send an
                 error to the client.

free_privdata:   called in order to free the privata data that is passed
                 by RedisModule_UnblockClient() call.
</code></pre></div></div>

<h2 id="redismodule_unblockclient"><code class="language-plaintext highlighter-rouge">RedisModule_UnblockClient</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_UnblockClient(RedisModuleBlockedClient *bc, void *privdata);
</code></pre></div></div>

<p>Unblock a client blocked by <code class="language-plaintext highlighter-rouge">RedisModule_BlockedClient</code>. This will trigger
the reply callbacks to be called in order to reply to the client.
The ‘privdata’ argument will be accessible by the reply callback, so
the caller of this function can pass any value that is needed in order to
actually reply to the client.</p>

<p>A common usage for ‘privdata’ is a thread that computes something that
needs to be passed to the client, included but not limited some slow
to compute reply or some reply obtained via networking.</p>

<p>Note: this function can be called from threads spawned by the module.</p>

<h2 id="redismodule_abortblock"><code class="language-plaintext highlighter-rouge">RedisModule_AbortBlock</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_AbortBlock(RedisModuleBlockedClient *bc);
</code></pre></div></div>

<p>Abort a blocked client blocking operation: the client will be unblocked
without firing the reply callback.</p>

<h2 id="redismodule_isblockedreplyrequest"><code class="language-plaintext highlighter-rouge">RedisModule_IsBlockedReplyRequest</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_IsBlockedReplyRequest(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Return non-zero if a module command was called in order to fill the
reply for a blocked client.</p>

<h2 id="redismodule_isblockedtimeoutrequest"><code class="language-plaintext highlighter-rouge">RedisModule_IsBlockedTimeoutRequest</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_IsBlockedTimeoutRequest(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Return non-zero if a module command was called in order to fill the
reply for a blocked client that timed out.</p>

<h2 id="redismodule_getblockedclientprivatedata"><code class="language-plaintext highlighter-rouge">RedisModule_GetBlockedClientPrivateData</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *RedisModule_GetBlockedClientPrivateData(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Get the privata data set by <code class="language-plaintext highlighter-rouge">RedisModule_UnblockClient()</code></p>

<h2 id="redismodule_getthreadsafecontext"><code class="language-plaintext highlighter-rouge">RedisModule_GetThreadSafeContext</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleCtx *RedisModule_GetThreadSafeContext(RedisModuleBlockedClient *bc);
</code></pre></div></div>

<p>Return a context which can be used inside threads to make Redis context
calls with certain modules APIs. If ‘bc’ is not NULL then the module will
be bound to a blocked client, and it will be possible to use the
``RedisModule_Reply<code class="language-plaintext highlighter-rouge">*</code> family of functions to accumulate a reply for when the
client will be unblocked. Otherwise the thread safe context will be
detached by a specific client.</p>

<p>To call non-reply APIs, the thread safe context must be prepared with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModule_ThreadSafeCallStart(ctx);
... make your call here ...
RedisModule_ThreadSafeCallStop(ctx);
</code></pre></div></div>

<p>This is not needed when using ``RedisModule_Reply<code class="language-plaintext highlighter-rouge">*</code> functions, assuming
that a blocked client was used when the context was created, otherwise
no <code class="language-plaintext highlighter-rouge">RedisModule_Reply</code>* call should be made at all.</p>

<p>TODO: thread safe contexts do not inherit the blocked client
selected database.</p>

<h2 id="redismodule_freethreadsafecontext"><code class="language-plaintext highlighter-rouge">RedisModule_FreeThreadSafeContext</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_FreeThreadSafeContext(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Release a thread safe context.</p>

<h2 id="redismodule_threadsafecontextlock"><code class="language-plaintext highlighter-rouge">RedisModule_ThreadSafeContextLock</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_ThreadSafeContextLock(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Acquire the server lock before executing a thread safe API call.
This is not needed for ``RedisModule_Reply<code class="language-plaintext highlighter-rouge">*</code> calls when there is
a blocked client connected to the thread safe context.</p>

<h2 id="redismodule_threadsafecontextunlock"><code class="language-plaintext highlighter-rouge">RedisModule_ThreadSafeContextUnlock</code></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void RedisModule_ThreadSafeContextUnlock(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>Release the server lock after a thread safe API call was executed.</p>


	</article>
	
</div>
<script>
		if(isRediscnPc()){
			var s = "_" + Math.random().toString(36).slice(2);
			document.write('<div style="margin-bottom:10px;" id="' + s + '"></div>');
			(window.slotbydup = window.slotbydup || []).push({
				id: "u3556359",
				container:  s
			});
			document.write('<scr'+'ipt type="text/javascr'+'ipt" src="//cpro.baidustatic.com/cpro/ui/c.js" async="async" defer="defer" ></scr'+'ipt>');
		}
	
</script>

<div id='disqus_thread' style="border:1px solid #CDCDCD;background-color:#CDCDCD;"></div>
      <script type='text/javascript'>
      $(document).ready(function(){ 
      		$.get("http://bbs.redis.cn/forum.php?mod=viewthread1&tid=2017", function(result){
				    $("#disqus_thread").html(result);
				  });
      });
      </script>
</div>

<footer class='site-footer'>
        <div class='container'>
          本站资源翻译自<a href="http://redis.io" target="_blank">redis.io</a>，
					由<a src="./aboutus.html">redis.cn翻译团队</a>翻译，
					更新日志请点击<a src="./update.html">这里</a>查看，
					翻译原文版权归redis.io官方所有，翻译不正确的地方欢迎大家指出。<br> 
					感谢各界爱心人士的热心捐赠，CRUG的成长离不开大家的帮助和支持，特别是<a src="./donation.html">Redis捐赠清单</a>里面的各位伙伴。<br>
					联系Email:<a href="mailto:admin@redis.cn">admin@redis.cn</a>，
					redis交流群：<a href="#">579708237</a> &nbsp; 
					<a href="https://beian.miit.gov.cn" target="_blank">京ICP备15003959号-2</a> &nbsp;
					<script src='http://s22.cnzz.com/stat.php?id=3593514&web_id=3593514' language='JavaScript'></script>
					<br>    
					<span style="font-weight:bold;color:#000000;">友情链接：</span>
					<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=fvilu0rm" target="_blank">阿里云</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">DBA的罗浮宫</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">VIP-陈群博客</a> &nbsp;
					<a href="http://lib.csdn.net/base/redis" target="_blank">Redis-知识库</a> &nbsp;
					<a href="http://www.kubernetes.org.cn" target="_blank" >Kubernetes</a> &nbsp;	
					<a href="https://www.fanghouguo.com" target="_blank" >方后国的博客</a> &nbsp;	
					<a href="https://aff.gae1s.com/aff.php?aff=10022" target="_blank" >ChromeGAE</a> &nbsp;	
					<a href="http://top.chinaz.com/" target="_blank" >网站排行榜</a> &nbsp;	
        </div>
      </footer>
    </div>
  </body>
</html>


<script>
	if(!isMobileBrowser()){
		window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"0","bdPos":"right","bdTop":"54.5"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	}
</script>

<script type='text/javascript'>
lastScrollY=0;

function heartBeat(){ 
	var diffY;
	if (document.documentElement && document.documentElement.scrollTop)
	diffY = document.documentElement.scrollTop;
	else if (document.body)
	diffY = document.body.scrollTop
	else
	{/*Netscape stuff*/}
	//alert(diffY);
	percent=.1*(diffY-lastScrollY); 
	if(percent>0)percent=Math.ceil(percent); 
	else percent=Math.floor(percent); 
	document.getElementById("lovexin12").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	document.getElementById("lovexin14").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	lastScrollY=lastScrollY+percent; 
	//alert(lastScrollY);
}

if(!isMobileBrowser()){
		//suspendcode12="<DIV id=\"lovexin12\" style='width:120px;height:270px;left:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://bbs.huaweicloud.com/forum/thread-16526-1-1.html' target='_blank'><img src='./images/couplets/hw_cp_20190411_01.png'/></a></div>"
		//suspendcode14="<DIV id=\"lovexin14\" style='width:120px;height:270px;right:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://activity.huaweicloud.com/2019june_promotion/index.html?utm_source=huawei&utm_medium=other&utm_campaign=618dacu&utm_content=0614#app-connection' target='_blank'><img src='./images/couplets/hw_cp_20190612.png'/></a></div>"
		//document.write(suspendcode12); 
		//document.write(suspendcode14); 
		//window.setInterval("heartBeat()",1);
}

$(document).ready(function(){ 
	
});
</script>
