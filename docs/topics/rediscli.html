<!DOCTYPE html>
<html>
	<head>
    <meta charset='utf-8' />
    <link rel="stylesheet" href="/css/styles.css?1436966512">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href='/images/favicon.png' rel='shortcut icon' />
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>REDIS rediscli -- Redis中国用户组（CRUG）</title>
    <meta name="description" content="redis
">
		<script src='/js/jquery-2.0.3.min.js?1426205838'></script>
		<script src='/js/slideout.js?1426205838'></script>
		<script src='/js/app.js?1436878127'></script>
		<script src='/js/base.js?1436878127'></script>
  </head>

<body class=''>
    <div class='mobile-menu slideout-menu'>
      <header class='menu-header'></header>
      <section class='menu-section'>
        <ul class='menu-section-list'>
          <li>
            <a class='home' href='/'>首页</a>
          </li>
          <li>
            <a href='/commands.html'>命令</a>
          </li>
          <li>
            <a href='/clients.html'>客户端</a>
          </li>
          <li>
            <a href='/documentation.html'>文档</a>
          </li>
          <li>
            <a href='/community.html'>社区</a>
          </li>
          <li>
            <a href='/download.html'>下载</a>
          </li>
          <li>
            <a href='/support.html'>支持</a>
          </li>
          <li>
            <a href='/topics/license.html'>许可</a>
          </li>
          <li>
            <a href='/update.html'>更新日志</a>
          </li>
          <li>
            <a href='/articles.html'>文章大全</a>
          </li>
		  <li>
            <a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </li>
          
        </ul>
      </section>
    </div>
    <div class='site-wrapper'>
      <header class='site-header'>
        <nav class='container'>
          <div class='mobile-header'>
            <button class='btn-hamburger js-slideout-toggle'>
              <span class='fa fa-bars'></span>
            </button>
            <a class='home' href='/'>
              <img alt='Redis' src='/images/redis-white.png' />
            </a>
          </div>
          <div class='desktop-header'>
            <a class='home' href='/'>
              <img alt='Redis' src='/images/redis-white.png' />
            </a>
            <a href='/commands.html'>命令</a>
            <a href='/clients.html'>客户端</a>
            <a href='/documentation.html'>文档</a>
            <a href='/community.html'>社区</a>
            <a href='/download.html'>下载</a>
            <a href='/support.html'>支持</a>
            <a href='/topics/license.html'>许可</a>
            <a href='/update.html'>更新日志</a>
            <a href='/articles.html'>文章大全</a>
			<a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </div>
        </nav>
      </header>
      <header class='site-header' style="background-color: #ffffff;">
        <!--
        <nav class='container'>
        	<a href="https://activity.huaweicloud.com/support_plan/index.html?utm_source=huawei&utm_medium=banner&utm_campaign=armredis&utm_content=0624&utm_term=crug" target="_blank">
				<img src="/images/bn/huawei_redis_08.png" style="width:100%;"/>
			</a>
        </nav>
      -->
      </header>
      <div class='site-content'>
<div class='text'>
	<article id='topic'>
		<h1 id="redis-cli-the-redis-command-line-interface">redis-cli, the Redis command line interface</h1>

<p><code class="language-plaintext highlighter-rouge">redis-cli</code> is the Redis command line interface, a simple program that allows
to send commands to Redis, and read the replies sent by the server, directly
from the terminal.</p>

<p>It has two main modes: an interactive mode where there is a REPL (Read
Eval Print Loop) where the user types commands and get replies; and another
mode where the command is sent as arguments of <code class="language-plaintext highlighter-rouge">redis-cli</code>, executed, and
printed on the standard output.</p>

<p>In interactive mode, <code class="language-plaintext highlighter-rouge">redis-cli</code> has basic line editing capabilities to provide
a good typing experience.</p>

<p>However <code class="language-plaintext highlighter-rouge">redis-cli</code> is not just that. There are options you can use to launch
the program in order to put it into special modes, so that <code class="language-plaintext highlighter-rouge">redis-cli</code> can
definitely do more complex tasks, like simulate a slave and print the
replication stream it receives from the master, check the latency of a Redis
server and show statistics or even an ASCII-art spectrogram of latency
samples and frequencies, and many other things.</p>

<p>This guide will cover the different aspects of <code class="language-plaintext highlighter-rouge">redis-cli</code>, starting from the
simplest and ending with the more advanced ones.</p>

<p>If you are going to use Redis extensively, or if you already do, chances are
you happen to use <code class="language-plaintext highlighter-rouge">redis-cli</code> a lot. Spending some time to familiarize with
it is likely a very good idea, you’ll see that you’ll work more effectively
with Redis once you know all the tricks of its command line interface.</p>

<h1 id="command-line-usage">Command line usage</h1>

<p>To just run a command and have its reply printed on the standard output is as
simple as typing the command to execute as separated arguments of <code class="language-plaintext highlighter-rouge">redis-cli</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli incr mycounter
(integer) 7
</code></pre></div></div>

<p>The reply of the command is “7”. Since Redis replies are typed (they can be
strings, arrays, integers, NULL, errors and so forth), you see the type
of the reply between brackets. However that would be not exactly a great idea
when the output of <code class="language-plaintext highlighter-rouge">redis-cli</code> must be used as input of another command, or when
we want to redirect it into a file.</p>

<p>Actually <code class="language-plaintext highlighter-rouge">redis-cli</code> only shows additional information which improves
readability for humans when it detects the standard output is a tty (a terminal
basically). Otherwise it will auto-enable the <em>raw output mode</em>, like in the
following example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli incr mycounter &gt; /tmp/output.txt
$ cat /tmp/output.txt
8
</code></pre></div></div>

<p>This time <code class="language-plaintext highlighter-rouge">(integer)</code> was omitted from the output since the CLI detected
the output was no longer written to the terminal. You can force raw output
even on the terminal with the <code class="language-plaintext highlighter-rouge">--raw</code> option:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --raw incr mycounter
9
</code></pre></div></div>

<p>Similarly, you can force human readable output when writing to a file or in
pipe to other commands by using <code class="language-plaintext highlighter-rouge">--no-raw</code>.</p>

<h2 id="host-port-password-and-database">Host, port, password and database</h2>

<p>By default <code class="language-plaintext highlighter-rouge">redis-cli</code> connects to the server at 127.0.0.1 port 6379.
As you can guess, you can easily change this using command line options.
To specify a different host name or an IP address, use <code class="language-plaintext highlighter-rouge">-h</code>. In order
to set a different port, use <code class="language-plaintext highlighter-rouge">-p</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli -h redis15.localnet.org -p 6390 ping
PONG
</code></pre></div></div>

<p>If your instance is password protected, the <code class="language-plaintext highlighter-rouge">-a &lt;password&gt;</code> option will
preform authentication saving the need of explicitly using the <code class="language-plaintext highlighter-rouge">AUTH</code> command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli -a myUnguessablePazzzzzword123 ping
PONG
</code></pre></div></div>

<p>Finally, it’s possible to send a command that operates a on a database number
other than the default number zero by using the <code class="language-plaintext highlighter-rouge">-n &lt;dbnum&gt;</code> option:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli flushall
OK
$ redis-cli -n 1 incr a
(integer) 1
$ redis-cli -n 1 incr a
(integer) 2
$ redis-cli -n 2 incr a
(integer) 1
</code></pre></div></div>

<h2 id="getting-input-from-other-programs">Getting input from other programs</h2>

<p>There are two ways you can use <code class="language-plaintext highlighter-rouge">redis-cli</code> in order to get the input from other
commands (from the standard input, basically). One is to use as last argument
the payload we read from <em>stdin</em>. For example, in order to set a Redis key
to the content of the file <code class="language-plaintext highlighter-rouge">/etc/services</code> if my computer, I can use the <code class="language-plaintext highlighter-rouge">-x</code>
option:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli -x set foo &lt; /etc/services
OK
$ redis-cli getrange foo 0 50
"#\n# Network services, Internet style\n#\n# Note that "
</code></pre></div></div>

<p>As you can see in the first line of the above session, the last argument of the
<code class="language-plaintext highlighter-rouge">SET</code> command was not specified. The arguments are just <code class="language-plaintext highlighter-rouge">SET foo</code> without the
actual value I want my key to be set to.</p>

<p>Instead, the <code class="language-plaintext highlighter-rouge">-x</code> option was specified and a file was redirected to the CLI’s
standard input. So the input was read, and was used as the final argument for
the command. This is useful for scripting.</p>

<p>A different approach is to feed <code class="language-plaintext highlighter-rouge">redis-cli</code> a sequence of commands written in a
text file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /tmp/commands.txt
set foo 100
incr foo
append foo xxx
get foo
$ cat /tmp/commands.txt | redis-cli
OK
(integer) 101
(integer) 6
"101xxx"
</code></pre></div></div>

<p>All the commands in <code class="language-plaintext highlighter-rouge">commands.txt</code> are executed one after the other by
<code class="language-plaintext highlighter-rouge">redis-cli</code> as if they were typed by the user interactive. Strings can be
quoted inside the file if needed, so that it’s possible to have single
arguments with spaces or newlines or other special chars inside:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /tmp/commands.txt
set foo "This is a single argument"
strlen foo
$ cat /tmp/commands.txt | redis-cli
OK
(integer) 25
</code></pre></div></div>

<h2 id="continuously-run-the-same-command">Continuously run the same command</h2>

<p>It is possible to execute the same command a specified number of times
with a user selected pause between the executions. This is useful in
different contexts, for example when we want to continuously monitor some
key content or <code class="language-plaintext highlighter-rouge">INFO</code> field output, or when we want to simulate some
recurring write event (like pushing a new item into a list every 5 seconds).</p>

<p>This feature is controlled by two options: <code class="language-plaintext highlighter-rouge">-r &lt;count&gt;</code> and <code class="language-plaintext highlighter-rouge">-i &lt;delay&gt;</code>.
The first states how many times to run a command, the second configures
the delay between the different command calls, in seconds (with the ability
to specify decimal numbers like 0.1 in order to mean 100 milliseconds).</p>

<p>By default the interval (or delay) is set to 0, so commands are just executed
ASAP:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli -r 5 incr foo
(integer) 1
(integer) 2
(integer) 3
(integer) 4
(integer) 5
</code></pre></div></div>

<p>To run the same command forever, use <code class="language-plaintext highlighter-rouge">-1</code> as count.
So, in order to monitor over time the RSS memory size it’s possible
to use a command like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli -r -1 -i 1 INFO | grep rss_human
used_memory_rss_human:1.38M
used_memory_rss_human:1.38M
used_memory_rss_human:1.38M
... a new line will be printed each second ...
</code></pre></div></div>

<h2 id="mass-insertion-of-data-using-redis-cli">Mass insertion of data using <code class="language-plaintext highlighter-rouge">redis-cli</code></h2>

<p>Mass insert using <code class="language-plaintext highlighter-rouge">redis-cli</code> is covered in a separated page since it’s a
worthwhile topic itself. Please refer to our
<a href="/topics/mass-insert">mass insertion guide</a>.</p>

<h2 id="csv-output">CSV output</h2>

<p>Sometimes you may want to use <code class="language-plaintext highlighter-rouge">redis-cli</code> in order to quickly export data from
Redis to an external program. This can be accomplished using the CSV (Comma
Separated Values) output feature:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli lpush mylist a b c d
(integer) 4
$ redis-cli --csv lrange mylist 0 -1
"d","c","b","a"
</code></pre></div></div>

<p>Currently it’s not possible to export the whole DB like that, but only to run
single commands with CSV output.</p>

<h2 id="running-lua-scripts">Running Lua scripts</h2>

<p>The <code class="language-plaintext highlighter-rouge">redis-cli</code> has extensive support for using the new Lua debugging facility
of Lua scripting, available starting with Redis 3.2. For this feature, please
refer to the <a href="/topics/ldb">Redis Lua debugger documentation</a>.</p>

<p>However, even without using the debugger, you can use <code class="language-plaintext highlighter-rouge">redis-cli</code> to
run scripts from a file in a way more comfortable compared to typing
the script interactively into the shell or as an argument:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /tmp/script.lua
return redis.call('set',KEYS[1],ARGV[1])
$ redis-cli --eval /tmp/script.lua foo , bar
OK
</code></pre></div></div>

<p>The Redis <code class="language-plaintext highlighter-rouge">EVAL</code> command takes the list of keys the script uses, and the
other non key arguments, as different arrays. When calling <code class="language-plaintext highlighter-rouge">EVAL</code> you
provide the number of keys as a number. However with <code class="language-plaintext highlighter-rouge">redis-cli</code> and using
the <code class="language-plaintext highlighter-rouge">--eval</code> option above, there is no need to specify the number of keys
explicitly. Instead it uses the convention of separating keys and arguments
with a comma. This is why in the above call you see <code class="language-plaintext highlighter-rouge">foo , bar</code> as arguments.</p>

<p>So <code class="language-plaintext highlighter-rouge">foo</code> will populate the <code class="language-plaintext highlighter-rouge">KEYS</code> array, and <code class="language-plaintext highlighter-rouge">bar</code> the <code class="language-plaintext highlighter-rouge">ARGV</code> array.</p>

<p>The <code class="language-plaintext highlighter-rouge">--eval</code> option is useful when writing simple scripts. For more
complex work, using the Lua debugger is definitely more comfortable. It’s
possible to mix the two approaches, since the debugger also uses executing
scripts from an external file.</p>

<h1 id="interactive-mode">Interactive mode</h1>

<p>So far we explored how to use the Redis CLI as a command line program.
This is very useful for scripts and certain types of testing, however most
people will spend the majority of time in <code class="language-plaintext highlighter-rouge">redis-cli</code> using its interactive
mode.</p>

<p>In interactive mode the user types Redis commands at the prompt. The command
is sent to the server, processed, and the reply is parsed back and rendered
into a simpler form to read.</p>

<p>Nothing special is needed for running the CLI in interactive mode -
just lunch it without any arguments and you are in:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli
127.0.0.1:6379&gt; ping
PONG
</code></pre></div></div>

<p>The string <code class="language-plaintext highlighter-rouge">127.0.0.1:6379&gt;</code> is the prompt. It reminds you that you are
connected to a given Redis instance.</p>

<p>The prompt changes as the server you are connected to changes, or when you
are operating on a database different than the database number zero:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; select 2
OK
127.0.0.1:6379[2]&gt; dbsize
(integer) 1
127.0.0.1:6379[2]&gt; select 0
OK
127.0.0.1:6379&gt; dbsize
(integer) 503
</code></pre></div></div>

<h2 id="handling-connections-and-reconnections">Handling connections and reconnections</h2>

<p>Using the <code class="language-plaintext highlighter-rouge">connect</code> command in interactive mode makes it possible to connect
to a different instance, by specifying the <em>hostname</em> and <em>port</em> we want
to connect to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; connect metal 6379
metal:6379&gt; ping
PONG
</code></pre></div></div>

<p>As you can see the prompt changes accordingly. If the user attempts to connect
to an instance that is unreachable, the <code class="language-plaintext highlighter-rouge">redis-cli</code> goes into disconnected
mode and attempts to reconnect with each new command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; connect 127.0.0.1 9999
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected&gt; ping
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected&gt; ping
Could not connect to Redis at 127.0.0.1:9999: Connection refused
</code></pre></div></div>

<p>Generally after a disconnection is detected, the CLI always attempts to
reconnect transparently: if the attempt fails, it shows the error and
enters the disconnected state. The following is an example of disconnection
and reconnection:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; debug restart
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected&gt; ping
PONG
127.0.0.1:6379&gt; (now we are connected again)
</code></pre></div></div>

<p>When a reconnection is performed, <code class="language-plaintext highlighter-rouge">redis-cli</code> automatically re-select the
last database number selected. However, all the other state about the
connection is lost, such as the state of a transaction if we
were in the middle of it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; ping
QUEUED

( here the server is manually restarted )

127.0.0.1:6379&gt; exec
(error) ERR EXEC without MULTI
</code></pre></div></div>

<p>This is usually not an issue when using the CLI in interactive mode for
testing, but you should be aware of this limitation.</p>

<h2 id="editing-history-and-completion">Editing, history and completion</h2>

<p>Because <code class="language-plaintext highlighter-rouge">redis-cli</code> uses the
<a href="http://github.com/antirez/linenoise">linenoise line editing library</a>, it
always has line editing capabilities, without depending on <code class="language-plaintext highlighter-rouge">libreadline</code> or
other optional libraries.</p>

<p>You can access an history of commands executed, in order to avoid retyping
them again and again, by pressing the arrow keys (up and down).
The history is preserved between restarts of the CLI, in a file called
<code class="language-plaintext highlighter-rouge">.rediscli_history</code> inside the user home directory, as specified
by the <code class="language-plaintext highlighter-rouge">HOME</code> environment variable. It is possible to use a different
history filename by setting the <code class="language-plaintext highlighter-rouge">REDISCLI_HISTFILE</code> environment variable,
and disable it by setting it to <code class="language-plaintext highlighter-rouge">/dev/null</code>.</p>

<p>The CLI is also able to perform command names completion by pressing the TAB
key, like in the following example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; Z&lt;TAB&gt;
127.0.0.1:6379&gt; ZADD&lt;TAB&gt;
127.0.0.1:6379&gt; ZCARD&lt;TAB&gt;
</code></pre></div></div>

<h2 id="running-the-same-command-n-times">Running the same command N times</h2>

<p>It’s possible to run the same command multiple times by prefixing the command
name by a number:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; 5 incr mycounter
(integer) 1
(integer) 2
(integer) 3
(integer) 4
(integer) 5
</code></pre></div></div>

<h2 id="showing-help-about-redis-commands">Showing help about Redis commands</h2>

<p>Redis has a number of <a href="/commands">commands</a> and sometimes, as you test things,
you may not remember the exact order of arguments. <code class="language-plaintext highlighter-rouge">redis-cli</code> provides online
help for most Redis commands, using the <code class="language-plaintext highlighter-rouge">help</code> command. The command can be used
in two forms:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">help @&lt;category&gt;</code> shows all the commands about a given category. The
categories are: <code class="language-plaintext highlighter-rouge">@generic</code>, <code class="language-plaintext highlighter-rouge">@list</code>, <code class="language-plaintext highlighter-rouge">@set</code>, <code class="language-plaintext highlighter-rouge">@sorted_set</code>, <code class="language-plaintext highlighter-rouge">@hash</code>,
<code class="language-plaintext highlighter-rouge">@pubsub</code>, <code class="language-plaintext highlighter-rouge">@transactions</code>, <code class="language-plaintext highlighter-rouge">@connection</code>, <code class="language-plaintext highlighter-rouge">@server</code>, <code class="language-plaintext highlighter-rouge">@scripting</code>,
<code class="language-plaintext highlighter-rouge">@hyperloglog</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">help &lt;commandname&gt;</code> shows specific help for the command given as argument.</li>
</ul>

<p>For example in order to show help for the <code class="language-plaintext highlighter-rouge">PFADD</code> command, use:</p>

<p>127.0.0.1:6379&gt; help PFADD</p>

<p>PFADD key element [element …]
  summary: Adds the specified elements to the specified HyperLogLog.
  since: 2.8.9</p>

<p>Note that <code class="language-plaintext highlighter-rouge">help</code> supports TAB completion as well.</p>

<h2 id="clearing-the-terminal-screen">Clearing the terminal screen</h2>

<p>Using the <code class="language-plaintext highlighter-rouge">clear</code> command in interactive mode clears the terminal’s screen.</p>

<h1 id="special-modes-of-operation">Special modes of operation</h1>

<p>So far we saw two main modes of <code class="language-plaintext highlighter-rouge">redis-cli</code>.</p>

<ul>
  <li>Command line execution of Redis commands.</li>
  <li>Interactive “REPL-like” usage.</li>
</ul>

<p>However the CLI performs other auxiliary tasks related to Redis that
are explained in the next sections:</p>

<ul>
  <li>Monitoring tool to show continuous stats about a Redis server.</li>
  <li>Scanning a Redis database for very large keys.</li>
  <li>Key space scanner with pattern matching.</li>
  <li>Acting as a <a href="/topics/pubsub">Pub/Sub</a> client to subscribe to channels.</li>
  <li>Monitoring the commands executed into a Redis instance.</li>
  <li>Checking the <a href="/topics/latency">latency</a> of a Redis server in different ways.</li>
  <li>Checking the scheduler latency of the local computer.</li>
  <li>Transferring RDB backups from a remote Redis server locally.</li>
  <li>Acting as a Redis slave for showing what a slave receives.</li>
  <li>Simulating <a href="/topics/lru-cache">LRU</a> workloads for showing stats about keys hits.</li>
  <li>A client for the Lua debugger.</li>
</ul>

<h2 id="continuous-stats-mode">Continuous stats mode</h2>

<p>This is probably one of the lesser known features of <code class="language-plaintext highlighter-rouge">redis-cli</code>, and one
very useful in order to monitor Redis instances in real time.
To enable this mode, the <code class="language-plaintext highlighter-rouge">--stat</code> option is used.
The output is very clear about the behavior of the CLI in this mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --stat
------- data ------ --------------------- load -------------------- - child -
keys       mem      clients blocked requests            connections
506        1015.00K 1       0       24 (+0)             7
506        1015.00K 1       0       25 (+1)             7
506        3.40M    51      0       60461 (+60436)      57
506        3.40M    51      0       146425 (+85964)     107
507        3.40M    51      0       233844 (+87419)     157
507        3.40M    51      0       321715 (+87871)     207
508        3.40M    51      0       408642 (+86927)     257
508        3.40M    51      0       497038 (+88396)     257
</code></pre></div></div>

<p>In this mode a new line is printed every second with useful information and
the difference between the old data point. You can easily understand what’s
happening with memory usage, clients connected, and so forth.</p>

<p>The <code class="language-plaintext highlighter-rouge">-i &lt;interval&gt;</code> option in this case works as a modifier in order to
change the frequency at which new lines are emitted. The default is one
second.</p>

<h2 id="scanning-for-big-keys">Scanning for big keys</h2>

<p>In this special mode, <code class="language-plaintext highlighter-rouge">redis-cli</code> works as a key space analyzer. It scans the
dataset for big keys, but also provides information about the data types
that the data set consists of. This mode is enabled with the <code class="language-plaintext highlighter-rouge">--bigkeys</code> option,
and produces quite a verbose output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --bigkeys

# Scanning the entire keyspace to find biggest keys as well as
# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec
# per 100 SCAN commands (not usually needed).

[00.00%] Biggest string found so far 'key-419' with 3 bytes
[05.14%] Biggest list   found so far 'mylist' with 100004 items
[35.77%] Biggest string found so far 'counter:__rand_int__' with 6 bytes
[73.91%] Biggest hash   found so far 'myobject' with 3 fields

-------- summary -------

Sampled 506 keys in the keyspace!
Total key length in bytes is 3452 (avg len 6.82)

Biggest string found 'counter:__rand_int__' has 6 bytes
Biggest   list found 'mylist' has 100004 items
Biggest   hash found 'myobject' has 3 fields

504 strings with 1403 bytes (99.60% of keys, avg size 2.78)
1 lists with 100004 items (00.20% of keys, avg size 100004.00)
0 sets with 0 members (00.00% of keys, avg size 0.00)
1 hashs with 3 fields (00.20% of keys, avg size 3.00)
0 zsets with 0 members (00.00% of keys, avg size 0.00)
</code></pre></div></div>

<p>In the first part of the output, each new key larger than the previous larger
key (of the same type) encountered is reported. The summary section
provides general stats about the data inside the Redis instance.</p>

<p>The program uses the <code class="language-plaintext highlighter-rouge">SCAN</code> command, so it can be executed against a busy
server without impacting the operations, however the <code class="language-plaintext highlighter-rouge">-i</code> option can be
used in order to throttle the scanning process of the specified fraction
of second for each 100 keys requested. For example, <code class="language-plaintext highlighter-rouge">-i 0.1</code> will slow down
the program execution a lot, but will also reduce the load on the server
to a tiny amount.</p>

<p>Note that the summary also reports in a cleaner form the biggest keys found
for each time. The initial output is just to provide some interesting info
ASAP if running against a very large data set.</p>

<h2 id="getting-a-list-of-keys">Getting a list of keys</h2>

<p>It is also possible to scan the key space, again in a way that does not
block the Redis server (which does happen when you use a command
like <code class="language-plaintext highlighter-rouge">KEYS *</code>), and print all the key names, or filter them for specific
patterns. This mode, like the <code class="language-plaintext highlighter-rouge">--bigkeys</code> option, uses the <code class="language-plaintext highlighter-rouge">SCAN</code> command,
so keys may be reported multiple times if the dataset is changing, but no
key would ever be missing, if that key was present since the start of the
iteration. Because of the command that it uses this option is called <code class="language-plaintext highlighter-rouge">--scan</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --scan | head -10
key-419
key-71
key-236
key-50
key-38
key-458
key-453
key-499
key-446
key-371
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">head -10</code> is used in order to print only the first lines of the
output.</p>

<p>Scanning is able to use the underlying pattern matching capability of
the <code class="language-plaintext highlighter-rouge">SCAN</code> command with the <code class="language-plaintext highlighter-rouge">--pattern</code> option.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --scan --pattern '*-11*'
key-114
key-117
key-118
key-113
key-115
key-112
key-119
key-11
key-111
key-110
key-116
</code></pre></div></div>

<p>Piping the output through the <code class="language-plaintext highlighter-rouge">wc</code> command can be used to count specific
kind of objects, by key name:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --scan --pattern 'user:*' | wc -l
3829433
</code></pre></div></div>

<h2 id="pubsub-mode">Pub/sub mode</h2>

<p>The CLI is able to publish messages in Redis Pub/Sub channels just using
the <code class="language-plaintext highlighter-rouge">PUBLISH</code> command. This is expected since the <code class="language-plaintext highlighter-rouge">PUBLISH</code> command is very
similar to any other command. Subscribing to channels in order to receive
messages is different - in this case we need to block and wait for
messages, so this is implemented as a special mode in <code class="language-plaintext highlighter-rouge">redis-cli</code>. Unlike
other special modes this mode is not enabled by using a special option,
but simply by using the <code class="language-plaintext highlighter-rouge">SUBSCRIBE</code> or <code class="language-plaintext highlighter-rouge">PSUBSCRIBE</code> command, both in
interactive or non interactive mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli psubscribe '*'
Reading messages... (press Ctrl-C to quit)
1) "psubscribe"
2) "*"
3) (integer) 1
</code></pre></div></div>

<p>The <em>reading messages</em> message shows that we entered Pub/Sub mode.
When another client publishes some message in some channel, like you
can do using <code class="language-plaintext highlighter-rouge">redis-cli PUBLISH mychannel mymessage</code>, the CLI in Pub/Sub
mode will show something such as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1) "pmessage"
2) "*"
3) "mychannel"
4) "mymessage"
</code></pre></div></div>

<p>This is very useful for debugging Pub/Sub issues.
To exit the Pub/Sub mode just process <code class="language-plaintext highlighter-rouge">CTRL-C</code>.</p>

<h2 id="monitoring-commands-executed-in-redis">Monitoring commands executed in Redis</h2>

<p>Similarly to the Pub/Sub mode, the monitoring mode is entered automatically
once you use the <code class="language-plaintext highlighter-rouge">MONITOR</code> mode. It will print all the commands received
by a Redis instance:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli monitor
OK
1460100081.165665 [0 127.0.0.1:51706] "set" "foo" "bar"
1460100083.053365 [0 127.0.0.1:51707] "get" "foo"
</code></pre></div></div>

<p>Note that it is possible to use to pipe the output, so you can monitor
for specific patterns using tools such as <code class="language-plaintext highlighter-rouge">grep</code>.</p>

<h2 id="monitoring-the-latency-of-redis-instances">Monitoring the latency of Redis instances</h2>

<p>Redis is often used in contexts where latency is very critical. Latency
involves multiple moving parts within the application, from the client library
to the network stack, to the Redis instance itself.</p>

<p>The CLI has multiple facilities for studying the latency of a Redis
instance and understanding the latency’s maximum, average and distribution.</p>

<p>The basic latency checking tool is the <code class="language-plaintext highlighter-rouge">--latency</code> option. Using this
option the CLI runs a loop where the <code class="language-plaintext highlighter-rouge">PING</code> command is sent to the Redis
instance, and the time to get a reply is measured. This happens 100
times per second, and stats are updated in a real time in the console:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --latency
min: 0, max: 1, avg: 0.19 (427 samples)
</code></pre></div></div>

<p>The stats are provided in milliseconds. Usually, the average latency of
a very fast instance tends to be overestimated a bit because of the
latency due to the kernel scheduler of the system running <code class="language-plaintext highlighter-rouge">redis-cli</code>
itself, so the average latency of 0.19 above may easily be 0.01 or less.
However this is usually not a big problem, since we are interested in
events of a few millisecond or more.</p>

<p>Sometimes it is useful to study how the maximum and average latencies
evolve during time. The <code class="language-plaintext highlighter-rouge">--latency-history</code> option is used for that
purpose: it works exactly like <code class="language-plaintext highlighter-rouge">--latency</code>, but every 15 seconds (by
default) a new sampling session is started from scratch:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --latency-history
min: 0, max: 1, avg: 0.14 (1314 samples) -- 15.01 seconds range
min: 0, max: 1, avg: 0.18 (1299 samples) -- 15.00 seconds range
min: 0, max: 1, avg: 0.20 (113 samples)^C
</code></pre></div></div>

<p>You can change the sampling sessions’ length with the <code class="language-plaintext highlighter-rouge">-i &lt;interval&gt;</code> option.</p>

<p>The most advanced latency study tool, but also a bit harder to
interpret for non experienced users, is the ability to use color terminals
to show a spectrum of latencies. You’ll see a colored output that indicate the
different percentages of samples, and different ASCII characters that indicate
different latency figures. This mode is enabled using the <code class="language-plaintext highlighter-rouge">--latency-dist</code>
option:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --latency-dist
(output not displayed, requires a color terminal, try it!)
</code></pre></div></div>

<p>There is another pretty unusual latency tool implemented inside <code class="language-plaintext highlighter-rouge">redis-cli</code>.
It does not check the latency of a Redis instance, but the latency of the
computer you are running <code class="language-plaintext highlighter-rouge">redis-cli</code> on. What latency you may ask?
The latency that’s intrinsic to the kernel scheduler, the hypervisor in case
of virtualized instances, and so forth.</p>

<p>We call it <em>intrinsic latency</em> because it’s opaque to the programmer, mostly.
If your Redis instance has bad latency regardless of all the obvious things
that may be the source cause, it’s worth to check what’s the best your system
can do by running <code class="language-plaintext highlighter-rouge">redis-cli</code> in this special mode directly in the system you
are running Redis servers on.</p>

<p>By measuring the intrinsic latency, you know that this is the baseline,
and Redis cannot outdo your system. In order to run the CLI
in this mode, use the <code class="language-plaintext highlighter-rouge">--intrinsic-latency &lt;test-time&gt;</code>. The test’s time
is in seconds, and specifies how many seconds <code class="language-plaintext highlighter-rouge">redis-cli</code> should check the
latency of the system it’s currently running on.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./redis-cli --intrinsic-latency 5
Max latency so far: 1 microseconds.
Max latency so far: 7 microseconds.
Max latency so far: 9 microseconds.
Max latency so far: 11 microseconds.
Max latency so far: 13 microseconds.
Max latency so far: 15 microseconds.
Max latency so far: 34 microseconds.
Max latency so far: 82 microseconds.
Max latency so far: 586 microseconds.
Max latency so far: 739 microseconds.

65433042 total runs (avg latency: 0.0764 microseconds / 764.14 nanoseconds per run).
Worst run took 9671x longer than the average latency.
</code></pre></div></div>

<p>IMPORTANT: this command must be executed on the computer you want to run Redis
server on, not on a different host. It does not even connect to a Redis instance
and performs the test only locally.</p>

<p>In the above case, my system cannot do better than 739 microseconds of worst
case latency, so I can expect certain queries to run in a bit less than 1
millisecond from time to time.</p>

<h2 id="remote-backups-of-rdb-files">Remote backups of RDB files</h2>

<p>During Redis replication’s first synchronization, the master and the slave
exchange the whole data set in form of an RDB file. This feature is exploited
by <code class="language-plaintext highlighter-rouge">redis-cli</code> in order to provide a remote backup facility, that allows to
transfer an RDB file from any Redis instance to the local computer running
<code class="language-plaintext highlighter-rouge">redis-cli</code>. To use this mode, call the CLI with the <code class="language-plaintext highlighter-rouge">--rdb &lt;dest-filename&gt;</code>
option:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --rdb /tmp/dump.rdb
SYNC sent to master, writing 13256 bytes to '/tmp/dump.rdb'
Transfer finished with success.
</code></pre></div></div>

<p>This is a simple but effective way to make sure you have disaster recovery
RDB backups of your Redis instance. However when using this options in
scripts or <code class="language-plaintext highlighter-rouge">cron</code> jobs, make sure to check the return value of the command.
If it is non zero, an error occurred like in the following example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --rdb /tmp/dump.rdb
SYNC with master failed: -ERR Can't SYNC while not connected with my master
$ echo $?
1
</code></pre></div></div>

<h2 id="slave-mode">Slave mode</h2>

<p>The slave mode of the CLI is an advanced feature useful for
Redis developers and for debugging operations.
It allows to inspect what a master sends to its slaves in the replication
stream in order to propagate the writes to its replicas. The option
name is simply <code class="language-plaintext highlighter-rouge">--slave</code>. This is how it works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli --slave
SYNC with master, discarding 13256 bytes of bulk transfer...
SYNC done. Logging commands from master.
"PING"
"SELECT","0"
"set","foo","bar"
"PING"
"incr","myconuter"
</code></pre></div></div>

<p>The command begins by discarding the RDB file of the first synchronization
and then logs each command received as in CSV format.</p>

<p>If you think some of the commands are not replicated correctly in your slaves
this is a good way to check what’s happening, and also useful information
in order to improve the bug report.</p>

<h2 id="performing-an-lru-simulation">Performing an LRU simulation</h2>

<p>Redis is often used as a cache with <a href="/topics/lru-cache">LRU eviction</a>.
Depending on the number of keys and the amount of memory allocated for the
cache (specified via the <code class="language-plaintext highlighter-rouge">maxmemory</code> directive), the amount of cache hits
and misses will change. Sometimes, simulating the rate of hits is very
useful to correctly provision your cache.</p>

<p>The CLI has a special mode where it performs a simulation of GET and SET
operations, using an 80-20% power law distribution in the requests pattern.
This means that 20% of keys will be requested 80% of times, which is a
common distribution in caching scenarios.</p>

<p>Theoretically, given the distribution of the requests and the Redis memory
overhead, it should be possible to compute the hit rate analytically with
with a mathematical formula. However, Redis can be configured with
different LRU settings (number of samples) and LRU’s implementation, which
is approximated in Redis, changes a lot between different versions. Similarly
the amount of memory per key may change between versions. That is why this
tool was built: its main motivation was for testing the quality of Redis’ LRU
implementation, but now is also useful in for testing how a given version 
behaves with the settings you had in mind for your deployment.</p>

<p>In order to use this mode, you need to specify the amount of keys
in the test. You also need to configure a <code class="language-plaintext highlighter-rouge">maxmemory</code> setting that 
makes sense as a first try.</p>

<p>IMPORTANT NOTE: Configuring the <code class="language-plaintext highlighter-rouge">maxmemory</code> setting in the Redis configuration
is crucial: if there is no cap to the maximum memory usage, the hit will
eventually be 100% since all the keys can be stored in memory. Or if you
specify too many keys and no maximum memory, eventually all the computer
RAM will be used. It is also needed to configure an appropriate
<em>maxmemory policy</em>, most of the times what you want is <code class="language-plaintext highlighter-rouge">allkeys-lru</code>.</p>

<p>In the following example I configured a memory limit of 100MB, and an LRU
simulation using 10 million keys.</p>

<p>WARNING: the test uses pipelining and will stress the server, don’t use it
with production instances.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./redis-cli --lru-test 10000000
156000 Gets/sec | Hits: 4552 (2.92%) | Misses: 151448 (97.08%)
153750 Gets/sec | Hits: 12906 (8.39%) | Misses: 140844 (91.61%)
159250 Gets/sec | Hits: 21811 (13.70%) | Misses: 137439 (86.30%)
151000 Gets/sec | Hits: 27615 (18.29%) | Misses: 123385 (81.71%)
145000 Gets/sec | Hits: 32791 (22.61%) | Misses: 112209 (77.39%)
157750 Gets/sec | Hits: 42178 (26.74%) | Misses: 115572 (73.26%)
154500 Gets/sec | Hits: 47418 (30.69%) | Misses: 107082 (69.31%)
151250 Gets/sec | Hits: 51636 (34.14%) | Misses: 99614 (65.86%)
</code></pre></div></div>

<p>The program shows stats every second. As you see, in the first seconds
the cache starts to be populated. The misses rate later stabilizes into
the actual figure we can expect in the long time:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>120750 Gets/sec | Hits: 48774 (40.39%) | Misses: 71976 (59.61%)
122500 Gets/sec | Hits: 49052 (40.04%) | Misses: 73448 (59.96%)
127000 Gets/sec | Hits: 50870 (40.06%) | Misses: 76130 (59.94%)
124250 Gets/sec | Hits: 50147 (40.36%) | Misses: 74103 (59.64%)
</code></pre></div></div>

<p>A miss rage of 59% may not be acceptable for our use case. So we know that
100MB of memory are no enough. Let’s try with half gigabyte. After a few
minutes we’ll see the output to stabilize to the following figures:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>140000 Gets/sec | Hits: 135376 (96.70%) | Misses: 4624 (3.30%)
141250 Gets/sec | Hits: 136523 (96.65%) | Misses: 4727 (3.35%)
140250 Gets/sec | Hits: 135457 (96.58%) | Misses: 4793 (3.42%)
140500 Gets/sec | Hits: 135947 (96.76%) | Misses: 4553 (3.24%)
</code></pre></div></div>

<p>So we know that with 500MB we are going well enough for our number of
keys (10 millions) and distribution (80-20 style).</p>

	</article>
	
</div>
<script>
		if(isRediscnPc()){
			var s = "_" + Math.random().toString(36).slice(2);
			document.write('<div style="margin-bottom:10px;" id="' + s + '"></div>');
			(window.slotbydup = window.slotbydup || []).push({
				id: "u3556359",
				container:  s
			});
			document.write('<scr'+'ipt type="text/javascr'+'ipt" src="//cpro.baidustatic.com/cpro/ui/c.js" async="async" defer="defer" ></scr'+'ipt>');
		}
	
</script>

<div id='disqus_thread' style="border:1px solid #CDCDCD;background-color:#CDCDCD;"></div>
      <script type='text/javascript'>
      $(document).ready(function(){ 
      		$.get("http://bbs.redis.cn/forum.php?mod=viewthread1&tid=1461", function(result){
				    $("#disqus_thread").html(result);
				  });
      });
      </script>
</div>

<footer class='site-footer'>
        <div class='container'>
          本站资源翻译自<a href="http://redis.io" target="_blank">redis.io</a>，
					由<a href="/aboutus.html">redis.cn翻译团队</a>翻译，
					更新日志请点击<a href="/update.html">这里</a>查看，
					翻译原文版权归redis.io官方所有，翻译不正确的地方欢迎大家指出。<br> 
					感谢各界爱心人士的热心捐赠，CRUG的成长离不开大家的帮助和支持，特别是<a href="/donation.html">Redis捐赠清单</a>里面的各位伙伴。<br>
					联系Email:<a href="mailto:admin@redis.cn">admin@redis.cn</a>，
					redis交流群：<a href="#">579708237</a> &nbsp; 
					<a href="https://beian.miit.gov.cn" target="_blank">京ICP备15003959号-2</a> &nbsp;
					<script src='http://s22.cnzz.com/stat.php?id=3593514&web_id=3593514' language='JavaScript'></script>
					<br>    
					<span style="font-weight:bold;color:#000000;">友情链接：</span>
					<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=fvilu0rm" target="_blank">阿里云</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">DBA的罗浮宫</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">VIP-陈群博客</a> &nbsp;
					<a href="http://lib.csdn.net/base/redis" target="_blank">Redis-知识库</a> &nbsp;
					<a href="http://www.kubernetes.org.cn" target="_blank" >Kubernetes</a> &nbsp;	
					<a href="https://www.fanghouguo.com" target="_blank" >方后国的博客</a> &nbsp;	
					<a href="https://aff.gae1s.com/aff.php?aff=10022" target="_blank" >ChromeGAE</a> &nbsp;	
					<a href="http://top.chinaz.com/" target="_blank" >网站排行榜</a> &nbsp;	
        </div>
      </footer>
    </div>
  </body>
</html>


<script>
	if(!isMobileBrowser()){
		window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"0","bdPos":"right","bdTop":"54.5"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	}
</script>

<script type='text/javascript'>
lastScrollY=0;

function heartBeat(){ 
	var diffY;
	if (document.documentElement && document.documentElement.scrollTop)
	diffY = document.documentElement.scrollTop;
	else if (document.body)
	diffY = document.body.scrollTop
	else
	{/*Netscape stuff*/}
	//alert(diffY);
	percent=.1*(diffY-lastScrollY); 
	if(percent>0)percent=Math.ceil(percent); 
	else percent=Math.floor(percent); 
	document.getElementById("lovexin12").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	document.getElementById("lovexin14").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	lastScrollY=lastScrollY+percent; 
	//alert(lastScrollY);
}

if(!isMobileBrowser()){
		//suspendcode12="<DIV id=\"lovexin12\" style='width:120px;height:270px;left:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://bbs.huaweicloud.com/forum/thread-16526-1-1.html' target='_blank'><img src='/images/couplets/hw_cp_20190411_01.png'/></a></div>"
		//suspendcode14="<DIV id=\"lovexin14\" style='width:120px;height:270px;right:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://activity.huaweicloud.com/2019june_promotion/index.html?utm_source=huawei&utm_medium=other&utm_campaign=618dacu&utm_content=0614#app-connection' target='_blank'><img src='/images/couplets/hw_cp_20190612.png'/></a></div>"
		//document.write(suspendcode12); 
		//document.write(suspendcode14); 
		//window.setInterval("heartBeat()",1);
}

$(document).ready(function(){ 
	
});
</script>
