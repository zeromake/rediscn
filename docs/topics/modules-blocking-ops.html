<!DOCTYPE html>
<html>
	<head>
    <meta charset='utf-8' />
    <link rel="stylesheet" href="/css/styles.css?1436966512">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href='/images/favicon.png' rel='shortcut icon' />
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>REDIS index -- Redis中国用户组（CRUG）</title>
    <meta name="description" content="redis
">
		<script src='/js/jquery-2.0.3.min.js?1426205838'></script>
		<script src='/js/slideout.js?1426205838'></script>
		<script src='/js/app.js?1436878127'></script>
		<script src='/js/base.js?1436878127'></script>
  </head>

<body class=''>
    <div class='mobile-menu slideout-menu'>
      <header class='menu-header'></header>
      <section class='menu-section'>
        <ul class='menu-section-list'>
          <li>
            <a class='home' href='/'>首页</a>
          </li>
          <li>
            <a href='/commands.html'>命令</a>
          </li>
          <li>
            <a href='/clients.html'>客户端</a>
          </li>
          <li>
            <a href='/documentation.html'>文档</a>
          </li>
          <li>
            <a href='/community.html'>社区</a>
          </li>
          <li>
            <a href='/download.html'>下载</a>
          </li>
          <li>
            <a href='/support.html'>支持</a>
          </li>
          <li>
            <a href='/topics/license.html'>许可</a>
          </li>
          <li>
            <a href='/update.html'>更新日志</a>
          </li>
          <li>
            <a href='/articles.html'>文章大全</a>
          </li>
		  <li>
            <a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </li>
          
        </ul>
      </section>
    </div>
    <div class='site-wrapper'>
      <header class='site-header'>
        <nav class='container'>
          <div class='mobile-header'>
            <button class='btn-hamburger js-slideout-toggle'>
              <span class='fa fa-bars'></span>
            </button>
            <a class='home' href='/'>
              <img alt='Redis' src='/images/redis-white.png' />
            </a>
          </div>
          <div class='desktop-header'>
            <a class='home' href='/'>
              <img alt='Redis' src='/images/redis-white.png' />
            </a>
            <a href='/commands.html'>命令</a>
            <a href='/clients.html'>客户端</a>
            <a href='/documentation.html'>文档</a>
            <a href='/community.html'>社区</a>
            <a href='/download.html'>下载</a>
            <a href='/support.html'>支持</a>
            <a href='/topics/license.html'>许可</a>
            <a href='/update.html'>更新日志</a>
            <a href='/articles.html'>文章大全</a>
			<a href='http://bbs.redis.cn' target='_blank'>论坛</a>
          </div>
        </nav>
      </header>
      <header class='site-header' style="background-color: #ffffff;">
        <!--
        <nav class='container'>
        	<a href="https://activity.huaweicloud.com/support_plan/index.html?utm_source=huawei&utm_medium=banner&utm_campaign=armredis&utm_content=0624&utm_term=crug" target="_blank">
				<img src="/images/bn/huawei_redis_08.png" style="width:100%;"/>
			</a>
        </nav>
      -->
      </header>
      <div class='site-content'>
<div class='text'>
	<article id='topic'>
		<h1 id="redis-模块中的阻塞命令">Redis 模块中的阻塞命令</h1>

<p>Redis 有很多内嵌的阻塞命令。最常被使用的是<code class="language-plaintext highlighter-rouge">BLPOP</code>(或者<code class="language-plaintext highlighter-rouge">BRPOP</code>),它能阻塞对list中元素访问。</p>

<p>阻塞命令比较有意思的一点是它不阻塞整个服务器，仅阻塞调用客户端。通常我们希望某些事件发生，
所以触发阻塞比如:像在<code class="language-plaintext highlighter-rouge">BLPOP</code>中，Redis 数据发生改变，线程进行了长时间计算，接收到了大量的网络数据等等。</p>

<p>Redis 模块也可以实现阻塞功能，本文档会介绍模块的API，并给出阻塞命令可以使用的模式。</p>

<p>注意: 模块API 目前还是<em>实验性</em>的，仅在宏<em>REDISMODULE_EXPERIMENTAL_API</em>被定义是使用。
模块API的一些命令还未最终上线，后续还会有改动，因此现在不是最终版本。</p>

<p>如果要使用模块API，请在编译时添加头文件，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define REDISMODULE_EXPERIMENTAL_API
#include "redismodule.h"
</code></pre></div></div>

<h2 id="如何阻塞和恢复运行">如何阻塞和恢复运行</h2>
<p>注意：<code class="language-plaintext highlighter-rouge">src/modules</code>目录下的<code class="language-plaintext highlighter-rouge">helloblock.c</code>是阻塞的一个简单例子，可以用来了解阻塞API如何生效的。</p>

<p>在Redis的模块中，命令都是通过Redis核心的回调函数实现的，正常情况下，回调函数执行结束后就将结果返回给客户端，如果使用如下实现模块命令的函数，
客户端需要被置为阻塞状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RedisModuleBlockedClient *RedisModule_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(void*), long long timeout_ms);
</code></pre></div></div>

<p>函数返回<code class="language-plaintext highlighter-rouge">RedisModuleBlockedClient</code>对象，用于解除客户端的锁定。参数的意义如下:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ctx</code> API中表示命令执行的上下文</li>
  <li><code class="language-plaintext highlighter-rouge">reply_callback</code> 回调函数，同一般命令函数有相同原型，当解锁客户端时会调用该命令以便返回客户端信息</li>
  <li><code class="language-plaintext highlighter-rouge">timeout_callback</code> 回调函数，同一般命令函数有相同原型，当客户端到达超时时间（ms）调用</li>
  <li><code class="language-plaintext highlighter-rouge">free_privdata</code> 回调函数，用以释放私有数据。私有数据指API用来解锁客户端并传输给回调函数用以回复客户端的数据。处理机制本文后续会详细介绍。</li>
  <li><code class="language-plaintext highlighter-rouge">ms</code> 超时设置的毫秒数。当超过超时时间，超时回调函数会被调用，客户端自动退出。</li>
</ul>

<p>当客户端被阻塞时，如下API可对其进行解除阻塞：
    int RedisModule_UnblockClient(RedisModuleBlockedClient *bc, void *privdata);</p>

<p>该函数的参数是之前调用<code class="language-plaintext highlighter-rouge">RedisModule_BlockClient()</code>返回的阻塞客户端对象，它会解除客户端的阻塞。
当客户端被解除阻塞之前，指定的<code class="language-plaintext highlighter-rouge">reply_callback</code>函数会被调用：该函数拥有<code class="language-plaintext highlighter-rouge">privdata</code>的访问权限</p>

<p>注意：上述函数都是线程安全的，可在运行线程中被调用，来实现阻塞客户端的命令</p>

<p>当客户端被解除阻塞时，<code class="language-plaintext highlighter-rouge">free_privdata</code>会被调用，<code class="language-plaintext highlighter-rouge">privdata</code>会被自动释放。这样操作有很大好处，当客户端超时或者断开的时候，<code class="language-plaintext highlighter-rouge">reply callback</code> 永远都不会被调用，
所以如果数据需要被释放，可以让一个外部函数负责操作。</p>

<p>为了更好的理解API如何工作，我们可以想象这个例子，执行一个阻塞客户端1秒的命令，然后回复“Hello！”</p>

<p>注意: 为了使例子简单，例子命令中没有实现参数验证和其他一些非重要的项目。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,
                         int argc)
{
    RedisModuleBlockedClient *bc =
        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);

    pthread_t tid;
    pthread_create(&amp;tid,NULL,threadmain,bc);

    return REDISMODULE_OK;
}

void *threadmain(void *arg) {
    RedisModuleBlockedClient *bc = arg;

    sleep(1); /* Wait one second and unblock. */
    RedisModule_UnblockClient(bc,NULL);
}
</code></pre></div></div>

<p>上述命令会马上阻塞客户端，导致一个线程被阻塞1秒然后解除客户端阻塞。我们可以检测消息回复和超时回调函数回复，因为在本例中他们仅仅回复的类型不同，因此近乎是同一函数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int reply_func(RedisModuleCtx *ctx, RedisModuleString **argv,
               int argc)
{
    return RedisModule_ReplyWithSimpleString(ctx,"Hello!");
}

int timeout_func(RedisModuleCtx *ctx, RedisModuleString **argv,
               int argc)
{
    return RedisModule_ReplyWithNull(ctx);
}
</code></pre></div></div>

<p>回调函数仅回复客户端“Hello！”，比较重要的一点是回调函数在线程解锁客户端的时候被调用。</p>

<p>超时命令回复<code class="language-plaintext highlighter-rouge">NULL</code>，因为它经常在Redis 确实出现超时时发生</p>

<h2 id="解除阻塞时传递回复数据">解除阻塞时传递回复数据</h2>

<p>上述例子简单易懂，但缺少实际实现角度：回复函数需要知道返回什么给客户端，该信息是在客户端被解除阻塞后提供的。</p>

<p>对如上面例子做修改，线程在等待一秒后生成一个随机数。可认为这个是一个耗费资源的操作。随机数会传递给回复函数以便返回给命令调用者。</p>

<p>我们修改如下函数让上述描述能够运行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *threadmain(void *arg) {
    RedisModuleBlockedClient *bc = arg;

    sleep(1); /* Wait one second and unblock. */

    long *mynumber = RedisModule_Alloc(sizeof(long));
    *mynumber = rand();
    RedisModule_UnblockClient(bc,mynumber);
}
</code></pre></div></div>

<p>如你所见，解除阻塞函数调用，传递了私有数据–<code class="language-plaintext highlighter-rouge">mynumber</code> 指针–给回复调用函数。回复调用函数使用如下函数获取私有数据：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *RedisModule_GetBlockedClientPrivateData(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>回复函数调用修改如下：
    int reply_func(RedisModuleCtx <em>ctx, RedisModuleString **argv,
                   int argc)
    {
        long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);
        /</em> IMPORTANT: don’t free mynumber here, but in the
         * free privdata callback. */
        return RedisModule_ReplyWithLongLong(ctx,mynumber);
    }</p>

<p>因为分配给大值的资源必须被释放，当使用<code class="language-plaintext highlighter-rouge">RedisModule_BlockClient()</code> 阻塞客户端时，我们还需要传递<code class="language-plaintext highlighter-rouge">free_privdata</code>函数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void free_privdata(void *privdata) {
    RedisModule_Free(privdata);
}
</code></pre></div></div>

<p>注意：特别强调，最好在<code class="language-plaintext highlighter-rouge">free_privdata</code>回调中释放私有数据，因为回复函数有时会因为客户端断连或超时而没被调用。</p>

<p>另外还要注意一点：超时回调在使用<code class="language-plaintext highlighter-rouge">GetBlockedClientPrivateData()</code>API时可以访问私有数据。</p>

<h2 id="从一个客户端阻塞中退出">从一个客户端阻塞中退出</h2>

<p>还有一个问题有时会出现，为了实现非阻塞命令，需要分配资源。比如，我们阻塞客户端，然后，创建一个线程，但是线程创建失败，在这种场景下，如何恢复？
我们既不想让客户端一直阻塞，也不想调用<code class="language-plaintext highlighter-rouge">UnblockClient</code>,因为<code class="language-plaintext highlighter-rouge">UnblockClient</code>会触发一次回复函数调用。</p>

<p>在这种情况下，最好的方法是使用下面的函数：
    int RedisModule_AbortBlock(RedisModuleBlockedClient *bc);</p>

<p>使用方法如下：
    int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,
                             int argc)
    {
        RedisModuleBlockedClient *bc =
            RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pthread_t tid;
    if (pthread_create(&amp;tid,NULL,threadmain,bc) != 0) {
        RedisModule_AbortBlock(bc);
        RedisModule_ReplyWithError(ctx,"Sorry can't create a thread");
    }

    return REDISMODULE_OK;
}
</code></pre></div></div>

<p>客户端会被解除阻塞，但是不会触发恢复函数的调用。</p>

<h2 id="回复和超时回调可以使用一个函数">回复和超时回调可以使用一个函数</h2>

<p>使用如下函数来实现回复和超时回调使用同一个函数的功能：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int RedisModule_IsBlockedReplyRequest(RedisModuleCtx *ctx);
int RedisModule_IsBlockedTimeoutRequest(RedisModuleCtx *ctx);
</code></pre></div></div>

<p>因此，我可以在回复和超时回调函数使用同一个函数的条件下，重写上面的例子：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,
                         int argc)
{
    if (RedisModule_IsBlockedReplyRequest(ctx)) {
        long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);
        return RedisModule_ReplyWithLongLong(ctx,mynumber);
    } else if (RedisModule_IsBlockedTimeoutRequest) {
        return RedisModule_ReplyWithNull(ctx);
    }

    RedisModuleBlockedClient *bc =
        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);

    pthread_t tid;
    if (pthread_create(&amp;tid,NULL,threadmain,bc) != 0) {
        RedisModule_AbortBlock(bc);
        RedisModule_ReplyWithError(ctx,"Sorry can't create a thread");
    }

    return REDISMODULE_OK;
}
</code></pre></div></div>

<p>功能上相同的。但是大家更倾向清晰简洁的实现以及更多关注命令逻辑的一个单独函数。</p>

<h2 id="单线程内使用数据副本">单线程内使用数据副本</h2>

<p>如何和处理较慢命令的线程协同工作？有个有意思的解决方法是让这些线程使用数据的副本，因此，关于一个key的操作正在执行时，用户还是能看到
旧值。但是，当处理线程结束执行，新的值将被展示和使用。</p>

<p>该方法的例子如下
<a href="https://github.com/antirez/neural-redis">Neural Redis module</a>
当神经网络在其他线程训练的时候，用户仍然使用旧版本的模型</p>

<h2 id="未来工作">未来工作</h2>

<p>新的API在开发中，它可以让线程已更安全的方式来调用模块APIs，线程级命令也可以访问数据空间并做增量操作。</p>

<p>新特性目前没有ETA，但是它可能会在Redis 4.0中出现。</p>

	</article>
	
</div>
<script>
		if(isRediscnPc()){
			var s = "_" + Math.random().toString(36).slice(2);
			document.write('<div style="margin-bottom:10px;" id="' + s + '"></div>');
			(window.slotbydup = window.slotbydup || []).push({
				id: "u3556359",
				container:  s
			});
			document.write('<scr'+'ipt type="text/javascr'+'ipt" src="//cpro.baidustatic.com/cpro/ui/c.js" async="async" defer="defer" ></scr'+'ipt>');
		}
	
</script>

<div id='disqus_thread' style="border:1px solid #CDCDCD;background-color:#CDCDCD;"></div>
      <script type='text/javascript'>
      $(document).ready(function(){ 
      		$.get("http://bbs.redis.cn/forum.php?mod=viewthread1&tid=2015", function(result){
				    $("#disqus_thread").html(result);
				  });
      });
      </script>
</div>

<footer class='site-footer'>
        <div class='container'>
          本站资源翻译自<a href="http://redis.io" target="_blank">redis.io</a>，
					由<a href="/aboutus.html">redis.cn翻译团队</a>翻译，
					更新日志请点击<a href="/update.html">这里</a>查看，
					翻译原文版权归redis.io官方所有，翻译不正确的地方欢迎大家指出。<br> 
					感谢各界爱心人士的热心捐赠，CRUG的成长离不开大家的帮助和支持，特别是<a href="/donation.html">Redis捐赠清单</a>里面的各位伙伴。<br>
					联系Email:<a href="mailto:admin@redis.cn">admin@redis.cn</a>，
					redis交流群：<a href="#">579708237</a> &nbsp; 
					<a href="https://beian.miit.gov.cn" target="_blank">京ICP备15003959号-2</a> &nbsp;
					<script src='http://s22.cnzz.com/stat.php?id=3593514&web_id=3593514' language='JavaScript'></script>
					<br>    
					<span style="font-weight:bold;color:#000000;">友情链接：</span>
					<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=fvilu0rm" target="_blank">阿里云</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">DBA的罗浮宫</a> &nbsp;
					<a href="http://mdba.cn" target="_blank">VIP-陈群博客</a> &nbsp;
					<a href="http://lib.csdn.net/base/redis" target="_blank">Redis-知识库</a> &nbsp;
					<a href="http://www.kubernetes.org.cn" target="_blank" >Kubernetes</a> &nbsp;	
					<a href="https://www.fanghouguo.com" target="_blank" >方后国的博客</a> &nbsp;	
					<a href="https://aff.gae1s.com/aff.php?aff=10022" target="_blank" >ChromeGAE</a> &nbsp;	
					<a href="http://top.chinaz.com/" target="_blank" >网站排行榜</a> &nbsp;	
        </div>
      </footer>
    </div>
  </body>
</html>


<script>
	if(!isMobileBrowser()){
		window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"0","bdPos":"right","bdTop":"54.5"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	}
</script>

<script type='text/javascript'>
lastScrollY=0;

function heartBeat(){ 
	var diffY;
	if (document.documentElement && document.documentElement.scrollTop)
	diffY = document.documentElement.scrollTop;
	else if (document.body)
	diffY = document.body.scrollTop
	else
	{/*Netscape stuff*/}
	//alert(diffY);
	percent=.1*(diffY-lastScrollY); 
	if(percent>0)percent=Math.ceil(percent); 
	else percent=Math.floor(percent); 
	document.getElementById("lovexin12").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	document.getElementById("lovexin14").style.top=parseInt(document.getElementById
	("lovexin12").style.top)+percent+"px";
	lastScrollY=lastScrollY+percent; 
	//alert(lastScrollY);
}

if(!isMobileBrowser()){
		//suspendcode12="<DIV id=\"lovexin12\" style='width:120px;height:270px;left:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://bbs.huaweicloud.com/forum/thread-16526-1-1.html' target='_blank'><img src='/images/couplets/hw_cp_20190411_01.png'/></a></div>"
		//suspendcode14="<DIV id=\"lovexin14\" style='width:120px;height:270px;right:2px;POSITION:absolute;TOP:320px;z-index:3;'><a href='https://activity.huaweicloud.com/2019june_promotion/index.html?utm_source=huawei&utm_medium=other&utm_campaign=618dacu&utm_content=0614#app-connection' target='_blank'><img src='/images/couplets/hw_cp_20190612.png'/></a></div>"
		//document.write(suspendcode12); 
		//document.write(suspendcode14); 
		//window.setInterval("heartBeat()",1);
}

$(document).ready(function(){ 
	
});
</script>
